<haxe>
	<class path="Array" params="T" file="C:\Motion-Twin\haxe/std/Array.hx" extern="1">
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a copy of the Array. The values are not
		copied, only the Array structure.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of the array.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the Array content.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Removes [len] elements starting from [pos] an returns them.</haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element and returns it.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Reverse the order of elements of the Array.</haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of the array.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of the array and returns it.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of an array with [sep] for separating each element.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending [a] to [this].</haxe_doc>
		</concat>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The length of the Array</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<class path="Class" params="T" file="C:\Motion-Twin\haxe/std/Class.hx" extern="1"><haxe_doc>An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Date" params="" file="C:\Motion-Twin\haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.</haxe_doc>
		</fromString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.</haxe_doc>
		</toString>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the week day of the date (0-6 range).</haxe_doc>
		</getDay>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the day of the date (1-31 range).</haxe_doc>
		</getDate>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the month of the date (0-11 range).</haxe_doc>
		</getMonth>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the full year of the date.</haxe_doc>
		</getFullYear>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the seconds of the date (0-59 range).</haxe_doc>
		</getSeconds>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the minutes value of the date (0-59 range).</haxe_doc>
		</getMinutes>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the hours value of the date (0-23 range).</haxe_doc>
		</getHours>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.</haxe_doc>
		</getTime>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new date object.</haxe_doc>
		</new>
		<haxe_doc>The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.</haxe_doc>
	</class>
	<class path="Enum" params="T" file="C:\Motion-Twin\haxe/std/Enum.hx" extern="1"><haxe_doc>An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EnumValue" params="" file="C:\Motion-Twin\haxe/std/EnumValue.hx" extern="1"><haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Hash" params="T" file="C:\Motion-Twin\haxe/std/Hash.hx" extern="1">
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
	</class>
	<class path="IntHash" params="T" file="C:\Motion-Twin\haxe/std/IntHash.hx" extern="1">
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.</haxe_doc>
	</class>
	<class path="IntIter" params="" file="C:\Motion-Twin\haxe/std/IntIter.hx">
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<max><c path="Int"/></max>
		<min><c path="Int"/></min>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>Integer iterator. Used for interval implementation.</haxe_doc>
	</class>
	<class path="Lambda" params="" file="C:\Motion-Twin\haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an [Array] from an [Iterable]</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a [List] from an [Iterable]</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to [map], but also pass an index for each item iterated.</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if at least one element of the iterable is found by using the specific function.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if all elements of the iterable have the specified property defined by [f].</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>Call the function 'f' on all elements of the [Iterable] 'it'.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Return the list of elements matching the function 'f'</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional 'fold' using an [Iterable]</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>Count the number of elements in an [Iterable] having [pred] returning true.</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an iterable does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a list containing all items of 'a' followed by all items of 'b'</haxe_doc>
		</concat>
		<haxe_doc>The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.</haxe_doc>
	</class>
	<class path="LazyInst" params="" file="../src/LazyInst.hx">
		<_metaName line="16" static="1"><c path="String"/></_metaName>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="List" params="T" file="C:\Motion-Twin\haxe/std/List.hx">
		<map public="1" params="X" set="method" line="246">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted
		by the function [f].</haxe_doc>
		</map>
		<filter public="1" set="method" line="230">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].</haxe_doc>
		</filter>
		<join public="1" set="method" line="211">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Join the element of the list by using the separator [sep].</haxe_doc>
		</join>
		<toString public="1" set="method" line="191">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Makes the list empty.</haxe_doc>
		</clear>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" set="method" line="98">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<last public="1" set="method" line="88">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the last element of the list, or null
		if the list is empty.</haxe_doc>
		</last>
		<first public="1" set="method" line="80">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Push an element at the beginning of the list.</haxe_doc>
		</push>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the end of the list.</haxe_doc>
		</add>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of elements in this list.</haxe_doc>
		</length>
		<q><c path="Array"><d/></c></q>
		<h><c path="Array"><d/></c></h>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.</haxe_doc>
	</class>
	<class path="Math" params="" file="C:\Motion-Twin\haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="Reflect" params="" file="C:\Motion-Twin\haxe/std/Reflect.hx" extern="1">
		<hasField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an object has a field set. This doesn't take into account the object prototype (class methods).</haxe_doc>
		</hasField>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the field of an object, or null if [o] is not an object or doesn't have this field.</haxe_doc>
		</field>
		<setField public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set an object field value.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Similar to field but also supports property (might be slower).</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Similar to setField but also supports property (might be slower).</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of fields of an object, excluding its prototype (class methods).</haxe_doc>
		</fields>
		<isFunction public="1" set="method" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is a function or not.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Generic comparison function, does not work for methods, see [compareMethods]</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Compare two methods closures. Returns true if it's the same method of the same instance.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is an object or not.</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Delete an object field.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Make a copy of the fields of an object.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
	</class>
	<class path="Std" params="" file="C:\Motion-Twin\haxe/std/Std.hx" extern="1">
		<is public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t.</haxe_doc>
		</is>
		<string public="1" set="method" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Convert any value to a String</haxe_doc>
		</string>
		<int public="1" set="method" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Convert a Float to an Int, rounded down.</haxe_doc>
		</int>
		<parseInt public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Convert a String to a Float, parsing different possible reprensations.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Return a random integer between 0 included and x excluded.</haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
	</class>
	<enum path="Void" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc></enum>
	<class path="Float" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc></class>
	<class path="Int" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc></class>
	<typedef path="Iterator" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="C:\Motion-Twin\haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Returns a part of the String, taking from [startIndex] to [endIndex] - 1.
		If [endIndex] is not specified, length is used.
		If [startIndex] or [endIndex] is smaller than 0, than 0 is used.
		If [startIndex] > [endIndex] then they are swaped.]]></haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split the string using the specified delimiter.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Similar to [indexOf] but returns the latest index.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at the given position.
		Returns [null] if outside of String bounds.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at the given position.
		Returns the empty String if outside of String bounds.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been lowercased.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been uppercased.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of characters in the String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="C:\Motion-Twin\haxe/std/StringBuf.hx">
		<toString public="1" get="inline" set="null" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of the string buffer.
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<addSub public="1" get="inline" set="null" line="56">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a character to the string buffer.</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="49">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a part of a string to the string buffer.</haxe_doc>
		</addChar>
		<add public="1" get="inline" set="null" line="42">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the representation of any value to the string buffer.</haxe_doc>
		</add>
		<b><c path="String"/></b>
		<new public="1" set="method" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new string buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by
	appending small elements together.</haxe_doc>
	</class>
	<class path="StringTools" params="" file="C:\Motion-Twin\haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="41" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="68" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape HTML special characters of the string.</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="102" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Unescape HTML special characters of the string.</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="113" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] starts with the string [start].</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="126" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] ends with the string [end].</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="141" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string [s] at position [pos] is a space.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="149" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the left of the String [s].</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="170" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the right of the String [s].</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="192" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the beginning and the end of the String [s].</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="207" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its right until it reach [l] characters.</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="229" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its left until it reach [l] characters.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="254" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the string [sub] in the string [s] by the string [by].</haxe_doc>
		</replace>
		<hex public="1" set="method" line="269" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="292" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="322" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="C:\Motion-Twin\haxe/std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
		<haxe_doc>The diffent possible runtime types of a value.
	See [Type] for the haXe Reflection API.</haxe_doc>
	</enum>
	<class path="Type" params="" file="C:\Motion-Twin\haxe/std/Type.hx" extern="1">
		<getClass public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>Returns the class of a value or [null] if this value is not a Class instance.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Returns the enum of a value or [null] if this value is not an Enum instance.</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Returns the super-class of a class, or null if no super class.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of a class.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of an enum.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Evaluates a class from a name. The class must have been compiled
		to be accessible.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Evaluates an enum from a name. The enum must have been compiled
		to be accessible.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of the given class with the list of constructor arguments.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor name and parameters.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor index and parameters.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of instance fields.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of a class static fields.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns all the available constructor names for an enum.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of a value.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Recursively compare two enums constructors and parameters.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor of an enum</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns the parameters of an enum</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the constructor of an enum</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns the list of all enum values that don't take any parameter.</haxe_doc>
		</allEnums>
		<haxe_doc>The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.</haxe_doc>
	</class>
	<class path="cmtc.ds.hash.ObjectHash" params="Key:Val" file="../src/cmtc/ds/hash/ObjectHash.hx">
		<SAFE_NUM get="inline" set="null" line="15" static="1"><c path="Int"/></SAFE_NUM>
		<clsId line="16" static="1"><c path="Int"/></clsId>
		<hxUnserialize public="1" set="method" line="308"><f a="s">
	<c path="haxe.Unserializer"/>
	<e path="Void"/>
</f></hxUnserialize>
		<hxSerialize public="1" set="method" line="282"><f a="s">
	<c path="haxe.Serializer"/>
	<e path="Void"/>
</f></hxSerialize>
		<toString public="1" set="method" line="256"><f a=""><c path="String"/></f></toString>
		<iterator public="1" get="inline" set="null" line="230"><f a=""><t path="Iterator"><c path="cmtc.ds.hash.ObjectHash.Val"/></t></f></iterator>
		<keys public="1" set="method" line="204"><f a=""><t path="Iterator"><c path="cmtc.ds.hash.ObjectHash.Key"/></t></f></keys>
		<delete public="1" set="method" line="172"><f a="k">
	<c path="cmtc.ds.hash.ObjectHash.Key"/>
	<e path="Bool"/>
</f></delete>
		<exists public="1" set="method" line="146"><f a="k">
	<c path="cmtc.ds.hash.ObjectHash.Key"/>
	<e path="Bool"/>
</f></exists>
		<get public="1" set="method" line="119"><f a="k">
	<c path="cmtc.ds.hash.ObjectHash.Key"/>
	<t path="Null"><c path="cmtc.ds.hash.ObjectHash.Val"/></t>
</f></get>
		<getObjectId set="method" line="67"><f a="obj">
	<d/>
	<c path="Int"/>
</f></getObjectId>
		<set public="1" set="method" line="37"><f a="k:v">
	<c path="cmtc.ds.hash.ObjectHash.Key"/>
	<c path="cmtc.ds.hash.ObjectHash.Val"/>
	<e path="Void"/>
</f></set>
		<length public="1" set="null"><c path="Int"/></length>
		<ival><c path="IntHash"><c path="Array"><d/></c></c></ival>
		<new public="1" set="method" line="26"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author waneck</haxe_doc>
	</class>
	<class path="composure.core.ComposeItem" params="" file="../src/composure/core/ComposeItem.hx">
		<getRealTrait public="1" set="method" line="21" static="1"><f a="trait">
	<d/>
	<c path="composure.traits.ITrait"/>
</f></getRealTrait>
		<removeParentInjector set="method" line="301"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeParentInjector>
		<addParentInjector set="method" line="297"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addParentInjector>
		<onRootRemove set="method" line="288"><f a=""><e path="Void"/></f></onRootRemove>
		<onRootAdd set="method" line="281"><f a=""><e path="Void"/></f></onRootAdd>
		<onParentRemove set="method" line="271"><f a=""><e path="Void"/></f></onParentRemove>
		<onParentAdd set="method" line="261"><f a=""><e path="Void"/></f></onParentAdd>
		<removeTraitInjector set="method" line="246"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeTraitInjector>
		<addTraitInjector set="method" line="231"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addTraitInjector>
		<_removeTrait set="method" line="202"><f a="trait">
	<d/>
	<e path="Void"/>
</f></_removeTrait>
		<removeAllTraits public="1" set="method" line="197">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Removes all traits from this item.</haxe_doc>
		</removeAllTraits>
		<removeTraits public="1" set="method" line="189">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes a list of traits from this item.
	 * @see					addTrait
	 * @param	trait		The list of traits to remove from this item.</haxe_doc>
		</removeTraits>
		<removeTrait public="1" set="method" line="181">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes a trait from this item.
	 * @see					addTrait
	 * @param	trait		The trait to remove from this item.</haxe_doc>
		</removeTrait>
		<_addTrait set="method" line="148"><f a="trait">
	<d/>
	<e path="Void"/>
</f></_addTrait>
		<addTraits public="1" set="method" line="143">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds multiple traits to this item.
	 * @see					addTrait
	 * @param	traits		The traits to add to this item.</haxe_doc>
		</addTraits>
		<addTrait public="1" set="method" line="135">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds a trait to this item. Any type of object can be added, but if it implements ITrait
	 * it will have access to more information about the item and it's other traits. If, for structural reasons,
	 * it is inconvenient to implement ITrait, the object can expose a method called 'getProxiedTrait()' which should
	 * return an ITrait object to operate as it's proxy regarding other traits etc.
	 * @param	trait		The trait to add to this item.</haxe_doc>
		</addTrait>
		<callForTraits public="1" params="TraitType" set="method" line="125">
			<f a="func:?TraitType">
				<f a=":">
					<c path="composure.core.ComposeItem"/>
					<c path="callForTraits.TraitType"/>
					<e path="Void"/>
				</f>
				<c path="Class"><c path="callForTraits.TraitType"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Calls a function once for each trait that matches a certain type. The ComposeItem and
	 * trait are passed through as arguments. A function should have a signature like:<br/>
	 * <code>
	 * function myTraitFunction(item:ComposeItem, trait:ITrait):Void;
	 * </code>
	 * @param	func		The function to call.
	 * @param	TraitType	The type which the returned traits must implement.
	 * 						If no type is passed in, the function is called for all traits.]]></haxe_doc>
		</callForTraits>
		<getTraits public="1" params="TraitType" set="method" line="109">
			<f a="?TraitType">
				<c path="Class"><c path="getTraits.TraitType"/></c>
				<t path="Iterable"><c path="getTraits.TraitType"/></t>
			</f>
			<haxe_doc>* Gets a list of traits of a certain type.
	 * @param	TraitType		The type which the returned traits must implement.
	 * 							If no type is passed in, all traits are returned.
	 * @return		An array of traits, returns null if no matching traits are found.
	 * 				CAUTION: Do not modify the returned Array, for performance reasons,
	 * 				it is passed out by reference and reused internally.</haxe_doc>
		</getTraits>
		<getTrait public="1" params="TraitType" set="method" line="98">
			<f a="TraitType">
				<c path="Class"><c path="getTrait.TraitType"/></c>
				<c path="getTrait.TraitType"/>
			</f>
			<haxe_doc>* Gets the first trait of a certain type.
	 * @param	TraitType		The type which the returned trait must implement.
	 * @return		A trait object, returns null if no matching trait is found.</haxe_doc>
		</getTrait>
		<setRoot set="method" line="84"><f a="root">
	<c path="composure.core.ComposeRoot"/>
	<e path="Void"/>
</f></setRoot>
		<_traitToPair><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<t path="composure.traits.TraitPair"><d/></t>
</c></_traitToPair>
		<_traitToCast><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.traits.ITrait"/>
</c></_traitToCast>
		<_uniInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_uniInjectors>
		<_ascInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_ascInjectors>
		<_parentMarrier><c path="composure.injectors.InjectorMarrier"/></_parentMarrier>
		<_siblingMarrier><c path="composure.injectors.InjectorMarrier"/></_siblingMarrier>
		<_traitCollection><c path="composure.traits.TraitCollection"/></_traitCollection>
		<_root><c path="composure.core.ComposeRoot"/></_root>
		<_parentItem><c path="composure.core.ComposeGroup"/></_parentItem>
		<getRoot set="method" line="59"><f a=""><c path="composure.core.ComposeRoot"/></f></getRoot>
		<root public="1" get="getRoot" set="null">
			<c path="composure.core.ComposeRoot"/>
			<haxe_doc>* The ComposeRoot which is the top-level parent, if this is the root 'root' will be a self-reference.
	 * This value is set automatically and shouldn't be manually changed.</haxe_doc>
		</root>
		<setParentItem set="method" line="42"><f a="value">
	<c path="composure.core.ComposeGroup"/>
	<c path="composure.core.ComposeGroup"/>
</f></setParentItem>
		<getParentItem set="method" line="39"><f a=""><c path="composure.core.ComposeGroup"/></f></getParentItem>
		<parentItem public="1" get="getParentItem" set="setParentItem">
			<c path="composure.core.ComposeGroup"/>
			<haxe_doc>* The ComposeGroup to which this item is added, if this is the root 'parentItem' will be a self-reference.
	 * This value is set automatically and shouldn't be manually changed.</haxe_doc>
		</parentItem>
		<new public="1" set="method" line="76">
			<f a="?initTraits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param	initTraits		A list of traits to add to this ComposeItem initially.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* ComposeItem forms is the base class of all conceptual items in Composure.
 * It allows traits to be added and removed.<br/>
 * ComposeItem should only be used for performance critical items, it is recommended
 * that most items be represented by the subclass ComposeGroup, which adds the ability
 * to add/remove child items.
 * @author		Tom Byrne]]></haxe_doc>
	</class>
	<class path="composure.core.ComposeGroup" params="" file="../src/composure/core/ComposeGroup.hx">
		<extends path="composure.core.ComposeItem"/>
		<removeDescParentInjector set="method" line="344"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeDescParentInjector>
		<addDescParentInjector set="method" line="337"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addDescParentInjector>
		<checkForNewlyUnignoredInjectors set="method" line="319"><f a=""><e path="Void"/></f></checkForNewlyUnignoredInjectors>
		<checkForNewlyIgnoredInjectors set="method" line="300"><f a=""><e path="Void"/></f></checkForNewlyIgnoredInjectors>
		<removeParentInjector set="method" line="290" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeParentInjector>
		<addParentInjector set="method" line="280" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addParentInjector>
		<_removeAscendingInjector set="method" line="275"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></_removeAscendingInjector>
		<removeAscendingInjector public="1" set="method" line="267">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</removeAscendingInjector>
		<_addAscendingInjector set="method" line="258"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></_addAscendingInjector>
		<addAscendingInjector public="1" set="method" line="249">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</addAscendingInjector>
		<onParentRemove set="method" line="234" override="1"><f a=""><e path="Void"/></f></onParentRemove>
		<onParentAdd set="method" line="223" override="1"><f a=""><e path="Void"/></f></onParentAdd>
		<callForDescTraits public="1" params="TraitType" set="method" line="220">
			<f a="func:?TraitType">
				<f a=":">
					<c path="composure.core.ComposeItem"/>
					<d/>
					<e path="Void"/>
				</f>
				<c path="Class"><c path="callForDescTraits.TraitType"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Calls a function once for each descendant trait that matches a certain type. This ComposeGroup and
	 * the matched trait are passed through as arguments. A function should have a signature like:<br/>
	 * <code>
	 * function myTraitFunction(item:ComposeItem, trait:ITrait):Void;
	 * </code>
	 * @see					callForTraits
	 * @param	func		The function to call.
	 * @param	TraitType	The type which the returned traits must implement.
	 * 						If no type is passed in, the function is called for all traits.]]></haxe_doc>
		</callForDescTraits>
		<getDescTraits public="1" params="TraitType" set="method" line="206">
			<f a="?TraitType">
				<c path="Class"><c path="getDescTraits.TraitType"/></c>
				<t path="Iterable"><c path="getDescTraits.TraitType"/></t>
			</f>
			<haxe_doc>* Gets a list of traits of a certain type from any of this groups descendant items.
	 * @param	TraitType		The type which the returned trait must implement.
	 * @return		A trait object, returns null if no matching trait is found.</haxe_doc>
		</getDescTraits>
		<getDescTrait public="1" params="TraitType" set="method" line="198">
			<f a="TraitType">
				<c path="Class"><c path="getDescTrait.TraitType"/></c>
				<c path="getDescTrait.TraitType"/>
			</f>
			<haxe_doc>* Gets the first trait of a certain type from any of this groups descendant items.
	 * @param	TraitType		The type which the returned trait must implement.
	 * @return		A trait object, returns null if no matching trait is found.</haxe_doc>
		</getDescTrait>
		<removeTraitInjector set="method" line="184" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeTraitInjector>
		<addTraitInjector set="method" line="175" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addTraitInjector>
		<removeAllTraits public="1" set="method" line="171" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</removeAllTraits>
		<removeTraits public="1" set="method" line="164" override="1">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</removeTraits>
		<removeTrait public="1" set="method" line="157" override="1">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</removeTrait>
		<addTraits public="1" set="method" line="150" override="1">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</addTraits>
		<addTrait public="1" set="method" line="143" override="1">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</addTrait>
		<removeChildTrait public="1" set="method" line="136">
			<f a="traitPair">
				<t path="composure.traits.TraitPair"><d/></t>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</removeChildTrait>
		<addChildTrait public="1" set="method" line="128">
			<f a="traitPair">
				<t path="composure.traits.TraitPair"><d/></t>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</addChildTrait>
		<removeAllItem public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Removes all children from this ComposeGroup.</haxe_doc>
		</removeAllItem>
		<removeChild public="1" set="method" line="90">
			<f a="item">
				<c path="composure.core.ComposeItem"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes a child ComposeItem from this ComposeGroup.
	 * @param	item		A ComposeItem object to remove as a child from this group.</haxe_doc>
		</removeChild>
		<addChild public="1" set="method" line="60">
			<f a="item">
				<c path="composure.core.ComposeItem"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds a child ComposeItem to this ComposeGroup.
	 * @param	item		A ComposeItem object to add as a child to this group.</haxe_doc>
		</addChild>
		<setRoot set="method" line="50" override="1"><f a="game">
	<c path="composure.core.ComposeRoot"/>
	<e path="Void"/>
</f></setRoot>
		<_ignoredParentDescInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_ignoredParentDescInjectors>
		<_parentDescInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_parentDescInjectors>
		<_descInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_descInjectors>
		<_childAscendingMarrier><c path="composure.injectors.InjectorMarrier"/></_childAscendingMarrier>
		<_ignoredChildAscInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_ignoredChildAscInjectors>
		<_childAscInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_childAscInjectors>
		<_children><c path="org.tbyrne.collections.UniqueList"><c path="composure.core.ComposeItem"/></c></_children>
		<_descendantTraits><c path="composure.traits.TraitCollection"/></_descendantTraits>
		<get_children set="method" line="24"><f a=""><t path="Iterable"><c path="composure.core.ComposeItem"/></t></f></get_children>
		<children public="1" get="get_children" set="null"><t path="Iterable"><c path="composure.core.ComposeItem"/></t></children>
		<new public="1" set="method" line="42">
			<f a="?initTraits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param	initTraits		A list of traits to add to this ComposeItem initially.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* ComposeGroup is the core item used in Composure. It represents one conceptual object.
 * It shouldn't be directly overriden, instead it should be instantiated and then
 * populated with traits, each adding one atomic piece of behaviour.<br/>
 * ComposeGroup adds to the functionality of ComposeItem by allowing child items. For
 * performance critical items that will never need to house children, ComposeItem can
 * be used instead.
 * @author		Tom Byrne]]></haxe_doc>
	</class>
	<class path="composure.core.ComposeRoot" params="" file="../src/composure/core/ComposeRoot.hx">
		<extends path="composure.core.ComposeGroup"/>
		<removeUniversalInjector public="1" set="method" line="42">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</removeUniversalInjector>
		<addUniversalInjector public="1" set="method" line="35">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</addUniversalInjector>
		<getAllTraits public="1" set="method" line="28"><f a=""><c path="composure.traits.TraitCollection"/></f></getAllTraits>
		<_universalMarrier><c path="composure.injectors.InjectorMarrier"/></_universalMarrier>
		<new public="1" set="method" line="23"><f a="?initTraits">
	<c path="Array"><c path="composure.traits.ITrait"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* ComposeRoot is the root item for the Composure library.
 * When using Composure, one top-level ComposeRoot object should be
 * created. All other objects should then be added to this object or one
 * of it's descendants.<br/>
 * It is recommended that you do not add traits directly to the root object.
 * Adding them to some 'stage' or 'controller' item instead will allow your app
 * to coexist and interrelate with other Composure apps in future.<br/>
 * The only functional change ComposeRoot adds to ComposeGroup is that it's
 * 'root' property is a reference to itself.
 * @author		Tom Byrne]]></haxe_doc>
	</class>
	<class path="composure.injectors.IInjector" params="" file="../src/composure/injectors/IInjector.hx" interface="1">
		<isInterestedIn public="1" set="method"><f a="item:trait">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<e path="Bool"/>
</f></isInterestedIn>
		<shouldAscend public="1" set="method"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldAscend>
		<shouldDescend public="1" set="method"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldDescend>
		<injectorRemoved public="1" set="method"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorRemoved>
		<injectorAdded public="1" set="method"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorAdded>
		<ownerTraitTyped public="1"><c path="composure.traits.ITrait"/></ownerTraitTyped>
		<ownerTrait public="1"><d/></ownerTrait>
		<acceptOwnerTrait public="1" set="null"><e path="Bool"/></acceptOwnerTrait>
		<universal public="1" set="null"><e path="Bool"/></universal>
		<descendants public="1" set="null"><e path="Bool"/></descendants>
		<ascendants public="1" set="null"><e path="Bool"/></ascendants>
		<siblings public="1" set="null"><e path="Bool"/></siblings>
	</class>
	<class path="composure.injectors.AbstractInjector" params="" file="../src/composure/injectors/AbstractInjector.hx">
		<implements path="composure.injectors.IInjector"/>
		<isInterestedIn public="1" set="method" line="138"><f a="item:trait">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<e path="Bool"/>
</f></isInterestedIn>
		<shouldAscend public="1" set="method" line="131"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldAscend>
		<shouldDescend public="1" set="method" line="124"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldDescend>
		<itemMatchesAny set="method" line="116"><f a="item:traitTypes">
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><c path="Class"><d/></c></c>
	<e path="Bool"/>
</f></itemMatchesAny>
		<itemMatchesAll set="method" line="108"><f a="item:traitTypes">
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><c path="Class"><d/></c></c>
	<e path="Bool"/>
</f></itemMatchesAll>
		<injectorRemoved public="1" set="method" line="88"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorRemoved>
		<injectorAdded public="1" set="method" line="68"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorAdded>
		<_addedTraits><c path="org.tbyrne.collections.UniqueList"><d/></c></_addedTraits>
		<passThroughItem public="1"><e path="Bool"/></passThroughItem>
		<passThroughInjector public="1"><e path="Bool"/></passThroughInjector>
		<ownerTraitTyped public="1"><c path="composure.traits.ITrait"/></ownerTraitTyped>
		<ownerTrait public="1"><d/></ownerTrait>
		<_enumValMode><e path="Bool"/></_enumValMode>
		<set_interestedTraitType set="method" line="28"><f a="value">
	<d/>
	<d/>
</f></set_interestedTraitType>
		<interestedTraitType public="1" set="set_interestedTraitType"><d/></interestedTraitType>
		<maxMatches public="1"><c path="Int"/></maxMatches>
		<stopAscendingAt public="1"><f a="::">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<c path="composure.injectors.AbstractInjector"/>
	<e path="Bool"/>
</f></stopAscendingAt>
		<stopDescendingAt public="1"><f a="::">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<c path="composure.injectors.AbstractInjector"/>
	<e path="Bool"/>
</f></stopDescendingAt>
		<matchTrait public="1"><f a="::">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<c path="composure.injectors.AbstractInjector"/>
	<e path="Bool"/>
</f></matchTrait>
		<acceptOwnerTrait public="1"><e path="Bool"/></acceptOwnerTrait>
		<universal public="1"><e path="Bool"/></universal>
		<ascendants public="1"><e path="Bool"/></ascendants>
		<descendants public="1"><e path="Bool"/></descendants>
		<siblings public="1"><e path="Bool"/></siblings>
		<removeHandler public="1"><d/></removeHandler>
		<addHandler public="1"><d/></addHandler>
		<new public="1" set="method" line="50"><f a="interestedTraitType:addHandler:removeHandler:?siblings:?descendants:?ascendants:?universal">
	<d/>
	<d/>
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="composure.injectors.Injector" params="" file="../src/composure/injectors/Injector.hx">
		<extends path="composure.injectors.AbstractInjector"/>
		<new public="1" set="method" line="9"><f a="traitType:addHandler:removeHandler:?siblings:?descendants:?ascendants:?universal">
	<d/>
	<d/>
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="composure.injectors.InjectorMarrier" params="" file="../src/composure/injectors/InjectorMarrier.hx">
		<compareTrait set="method" line="122"><f a="traitPair:traitInjector">
	<t path="composure.traits.TraitPair"><d/></t>
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></compareTrait>
		<onTraitRemoved set="method" line="107"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></onTraitRemoved>
		<onTraitAdded set="method" line="101"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></onTraitAdded>
		<removeInjector public="1" set="method" line="73"><f a="traitInjector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeInjector>
		<addInjector public="1" set="method" line="55"><f a="traitInjector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addInjector>
		<_traitLookup><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c>
</c></_traitLookup>
		<_injectorLookup><c path="cmtc.ds.hash.ObjectHash">
	<c path="composure.injectors.IInjector"/>
	<c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><d/></t></c>
</c></_injectorLookup>
		<_traitInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_traitInjectors>
		<_traits><c path="composure.traits.TraitCollection"/></_traits>
		<getTraitInjectors set="method" line="34"><f a=""><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></f></getTraitInjectors>
		<traitInjectors public="1" get="getTraitInjectors" set="null"><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></traitInjectors>
		<set_traits set="method" line="19"><f a="value">
	<c path="composure.traits.TraitCollection"/>
	<c path="composure.traits.TraitCollection"/>
</f></set_traits>
		<get_traits set="method" line="16"><f a=""><c path="composure.traits.TraitCollection"/></f></get_traits>
		<traits public="1" get="get_traits" set="set_traits"><c path="composure.traits.TraitCollection"/></traits>
		<new public="1" set="method" line="47"><f a="traits">
	<c path="composure.traits.TraitCollection"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="composure.injectors.PropInjector" params="" file="../src/composure/injectors/PropInjector.hx">
		<extends path="composure.injectors.AbstractInjector"/>
		<removeProp set="method" line="38"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeProp>
		<addProp set="method" line="24"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addProp>
		<setTrait><d/></setTrait>
		<isSet><e path="Bool"/></isSet>
		<writeOnly><e path="Bool"/></writeOnly>
		<prop><c path="String"/></prop>
		<subject><d/></subject>
		<new public="1" set="method" line="16"><f a="interestedTraitType:subject:prop:?siblings:?descendants:?ascendants:?universal:?writeOnly">
	<d/>
	<d/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="composure.macro.InjectorMacro" params="" file="../src/composure/macro/InjectorMacro.hx"><haxe_doc><![CDATA[* The InjectorMacro is used to convert inject metadata into IInjector objects.
 * It gets run at compile-time using the build metadata:<br/>
 * '@build(composure.macro.InjectorMacro.inject())'<br/>
 * which should be added directly above your trait class definition.<br/>
 * <br/>
 * If your trait extends AbstractTrait, it needn't use the '@build' metadata
 * as all subclasses of AbstractTrait automatically get processed by the 
 * InjectorMacro.
 * 
 * @author Tom Byrne]]></haxe_doc></class>
	<class path="composure.macro._InjectorMacro.InjectorAccess" params="" file="../src/composure/macro/InjectorMacro.hx" private="1" module="composure.macro.InjectorMacro">
		<lazy public="1"><e path="Bool"/></lazy>
		<universal public="1"><e path="Bool"/></universal>
		<ascendants public="1"><e path="Bool"/></ascendants>
		<descendants public="1"><e path="Bool"/></descendants>
		<siblings public="1"><e path="Bool"/></siblings>
		<new public="1" set="method" line="319"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="composure.traitCheckers.GenerationChecker" params="" file="../src/composure/traitCheckers/GenerationChecker.hx">
		<create public="1" set="method" line="39" static="1">
			<f a="?maxGenerations:?descending:?relatedItem">
				<c path="Int"/>
				<e path="Bool"/>
				<e path="composure.traitCheckers.ItemType"/>
				<f a="::">
					<c path="composure.core.ComposeItem"/>
					<d/>
					<c path="composure.injectors.Injector"/>
					<e path="Bool"/>
				</f>
			</f>
			<haxe_doc><![CDATA[* The create method can be used to limit the scope of a certain Injector
	 * to a certain amount of generations. It generates a function which can be assigned
	 * to either the stopDescendingAt or stopAscendingAt properties of the Injector class.<br/>
	 * <br/>
	 * For example, if you wanted to get all position traits from child items (but not
	 * grandchild items) you could do something like this:
	 * <pre><code>
	 * var injector:Injector = new Injector(IPositionTrait, childPosAdded, childPosRemoved, false, true, false);
	 * injector.stopDescendingAt = GenerationChecker.create(1,true,ItemType.injectorItem);
	 * addInjector(injector);
	 * </code></pre>
	 * 
	 * @param maxGenerations The maximum amount of generations that the injector should
	 * have scope over. Defaults to '1', meaning the parent or child generation (depending on
	 * descending).
	 * 
	 * @param descending Whether the check should go up the hierarchy or down.
	 * 
	 * @param relatedItem Which ComposeItem/ComposeGroup should the generations be relative to.
	 * Defaults to the item which the trait is added.]]></haxe_doc>
		</create>
		<searchForDesc set="method" line="64" static="1"><f a="remainingGenerations:startGroup:findItem">
	<c path="Int"/>
	<c path="composure.core.ComposeGroup"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></searchForDesc>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<enum path="composure.traitCheckers.ItemType" params="" file="../src/composure/traitCheckers/GenerationChecker.hx" module="composure.traitCheckers.GenerationChecker">
		<specific a="ItemType"><c path="composure.core.ComposeItem"/></specific>
		<root/>
		<injectorItem/>
	</enum>
	<class path="composure.traitCheckers.MatchProps" params="" file="../src/composure/traitCheckers/MatchProps.hx">
		<create public="1" set="method" line="13" static="1"><f a="matchProps">
	<c path="Hash"><d/></c>
	<f a="::">
		<c path="composure.core.ComposeItem"/>
		<d/>
		<c path="composure.injectors.Injector"/>
		<e path="Bool"/>
	</f>
</f></create>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="composure.traitCheckers.TraitTypeChecker" params="" file="../src/composure/traitCheckers/TraitTypeChecker.hx">
		<createMulti public="1" set="method" line="14" static="1"><f a="types:?useOrCheck:?invertResponse:?unlessIsTraits:?dontMatchFrom">
	<c path="Array"><c path="Class"><d/></c></c>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Array"><d/></c>
	<e path="Bool"/>
	<f a="::">
		<c path="composure.core.ComposeItem"/>
		<d/>
		<c path="composure.injectors.Injector"/>
		<e path="Bool"/>
	</f>
</f></createMulti>
		<create public="1" set="method" line="37" static="1"><f a="type:?invertResponse:?unlessIsTrait:?dontMatchFrom">
	<c path="Class"><d/></c>
	<e path="Bool"/>
	<d/>
	<e path="Bool"/>
	<f a="::">
		<c path="composure.core.ComposeItem"/>
		<d/>
		<c path="composure.injectors.Injector"/>
		<e path="Bool"/>
	</f>
</f></create>
		<contains set="method" line="46" static="1"><f a="traits:trait">
	<c path="Array"><d/></c>
	<d/>
	<e path="Bool"/>
</f></contains>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="composure.traits.ITrait" params="" file="../src/composure/traits/ITrait.hx" interface="1">
		<getInjectors public="1" set="method">
			<f a=""><t path="Iterable"><c path="composure.injectors.IInjector"/></t></f>
			<haxe_doc>* This provides a way for this trait to gain access to other traits in the
	 * application.
	 * @return A list of IInjectors, each one describing which traits it is concerned with.</haxe_doc>
		</getInjectors>
		<group public="1" set="null">
			<c path="composure.core.ComposeGroup"/>
			<haxe_doc>* The group to which this item is added. This is a method of convenience,
	 * and should return the 'item' property cast as a ComposeGroup.</haxe_doc>
		</group>
		<item public="1" set="set_item">
			<c path="composure.core.ComposeItem"/>
			<haxe_doc>* The item which this trait is added to. Do not set this manually,
	 * the ComposeItem class sets this property automatically when the 
	 * trait is added to it.</haxe_doc>
		</item>
		<haxe_doc>* ITrait can be implemented by traits to give them access to the item
 * to which they are added. It also allows traits to return a list of 
 * injectors, which describe other traits (sibling, ascendant or descendant)
 * which this trait should gain access to.
 * 
 * @author		Tom Byrne</haxe_doc>
	</class>
	<class path="composure.traits.AbstractTrait" params="" file="../src/composure/traits/AbstractTrait.hx">
		<implements path="composure.traits.ITrait"/>
		<removeInjector public="1" set="method" line="196">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes an injector from this trait.
	 * @see addInjector
	 * @param injector The injector to remove from this trait.</haxe_doc>
		</removeInjector>
		<addInjector public="1" set="method" line="181">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds an injector to this trait, each injector is a description of a certain other trait
	 * that this trait would like access to.
	 * @param injector The injector to add to this trait.</haxe_doc>
		</addInjector>
		<removeChildItems set="method" line="170"><f a="children">
	<c path="Array"><c path="composure.core.ComposeItem"/></c>
	<e path="Void"/>
</f></removeChildItems>
		<removeChildItem set="method" line="160"><f a="child">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></removeChildItem>
		<addChildItem set="method" line="149"><f a="child">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></addChildItem>
		<removeSiblingTraits set="method" line="143"><f a="traits">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></removeSiblingTraits>
		<removeSiblingTrait set="method" line="133"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeSiblingTrait>
		<addSiblingTrait set="method" line="122"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addSiblingTrait>
		<getInjectors public="1" set="method" line="117">
			<f a=""><t path="Iterable"><c path="composure.injectors.IInjector"/></t></f>
			<haxe_doc>* This provides a way for this trait to gain access to other traits in the
	 * application.
	 * @return A list of IInjectors, each one describing which traits it is concerned with.</haxe_doc>
		</getInjectors>
		<onItemAdd set="method" line="108"><f a=""><e path="Void"/></f></onItemAdd>
		<onItemRemove set="method" line="105"><f a=""><e path="Void"/></f></onItemRemove>
		<_ownerTrait><d/></_ownerTrait>
		<_groupOnly>
			<e path="Bool"/>
			<haxe_doc>* Set to true to force Trait to only be added for groups.</haxe_doc>
		</_groupOnly>
		<_childItems><c path="org.tbyrne.collections.UniqueList"><c path="composure.core.ComposeItem"/></c></_childItems>
		<_siblingTraits><c path="org.tbyrne.collections.UniqueList"><d/></c></_siblingTraits>
		<_injectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_injectors>
		<set_item set="method" line="40"><f a="value">
	<c path="composure.core.ComposeItem"/>
	<c path="composure.core.ComposeItem"/>
</f></set_item>
		<item public="1" set="set_item">
			<c path="composure.core.ComposeItem"/>
			<haxe_doc>* The item which this trait is added to. Do not set this manually,
	 * the ComposeItem class sets this property automatically when the 
	 * trait is added to it.</haxe_doc>
		</item>
		<group public="1" set="null">
			<c path="composure.core.ComposeGroup"/>
			<haxe_doc>* The group to which this item is added. This is a method of convenience,
	 * and returns the 'item' property cast as a ComposeGroup.</haxe_doc>
		</group>
		<new public="1" set="method" line="97">
			<f a="?ownerTrait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param ownerTrait When using this Class as a Proxied Trait, pass through the actual trait
	 * object as the first parameter.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The AbstractTrait class can be extended by any trait to gain access
 * to the trait to which it is added. It also allows traits to access
 * other traits in the application either via the injection metadata
 * or via manually adding injectors via the addInjector method.<br/>
 * <br/>
 * If, for whatever reason, it is not possible or convenient to extend 
 * AbstractTrait, it is also possible to instantiate it within your trait
 * (passing <code>this</code> in as the constructor argument) and returning this
 * instance via a <code>getProxiedTrait</code> method. To use injection metadata in
 * this situation you must also add the <code>@build(composure.macro.InjectorMacro.inject())</code>
 * metadata to your class.
 * 
 * @author		Tom Byrne]]></haxe_doc>
		<meta>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<typedef path="composure.traits.TraitPair" params="TraitType" file="../src/composure/traits/ITrait.hx" module="composure.traits.ITrait"><a>
	<trait><c path="composure.traits.TraitPair.TraitType"/></trait>
	<item><c path="composure.core.ComposeItem"/></item>
</a></typedef>
	<class path="composure.traits.TraitCollection" params="" file="../src/composure/traits/TraitCollection.hx">
		<get_traitRemoved set="method" line="28"><f a=""><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></f></get_traitRemoved>
		<_traitRemoved><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></_traitRemoved>
		<get_traitAdded set="method" line="25"><f a=""><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></f></get_traitAdded>
		<_traitAdded><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></_traitAdded>
		<removeTrait public="1" set="method" line="173"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></removeTrait>
		<addTrait public="1" set="method" line="165"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></addTrait>
		<callForTraits public="1" params="TraitType" set="method" line="103"><f a="func:matchType:thisObj:?params:?collectReturns">
	<d/>
	<c path="Class"><c path="callForTraits.TraitType"/></c>
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></callForTraits>
		<validateCache public="1" params="TraitType" set="method" line="70"><f a="matchType">
	<c path="Class"><c path="validateCache.TraitType"/></c>
	<c path="composure.traits._TraitCollection.TraitTypeCache"><c path="validateCache.TraitType"/></c>
</f></validateCache>
		<getTraits public="1" params="TraitType" set="method" line="61"><f a="?TraitType">
	<c path="Class"><c path="getTraits.TraitType"/></c>
	<t path="Iterable"><c path="getTraits.TraitType"/></t>
</f></getTraits>
		<getTrait public="1" params="TraitType" set="method" line="47"><f a="TraitType">
	<c path="Class"><c path="getTrait.TraitType"/></c>
	<c path="getTrait.TraitType"/>
</f></getTrait>
		<traitPairs public="1" set="null"><c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><d/></t></c></traitPairs>
		<_traitTypeCache><c path="Hash"><c path="composure.traits._TraitCollection.TraitTypeCache"><d/></c></c></_traitTypeCache>
		<_testSignal><c path="msignal.Signal1"><d/></c></_testSignal>
		<get_testSignal set="method" line="31"><f a=""><c path="msignal.Signal1"><d/></c></f></get_testSignal>
		<testSignal public="1" get="get_testSignal" set="null"><c path="msignal.Signal1"><d/></c></testSignal>
		<traitRemoved public="1" get="get_traitRemoved" set="null">
			<c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c>
			<meta><m n="lazyInst"/></meta>
		</traitRemoved>
		<traitAdded public="1" get="get_traitAdded" set="null">
			<c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c>
			<meta><m n="lazyInst"/></meta>
		</traitAdded>
		<new public="1" set="method" line="41"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* The TraitCollection holds a collection of traits and has the
 * ability to compare them to a collection of injectors. This is 
 * used internally in Composure.
 * 
 * @author Tom Byrne</haxe_doc>
		<meta><m n=":build"><e>'???'</e></m></meta>
	</class>
	<class path="composure.traits._TraitCollection.TraitTypeCache" params="TraitType" file="../src/composure/traits/TraitCollection.hx" private="1" module="composure.traits.TraitCollection">
		<invalid public="1"><c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></t></c></invalid>
		<matched public="1"><c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></t></c></matched>
		<getTraitsList public="1"><c path="org.tbyrne.collections.UniqueList"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></c></getTraitsList>
		<getTraits public="1"><t path="Iterable"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></t></getTraits>
		<getTrait public="1"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></getTrait>
		<methodCachesSafe public="1"><e path="Bool"/></methodCachesSafe>
		<new public="1" set="method" line="195"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="composure.utilTraits.Furnisher" params="" file="../src/composure/utilTraits/Furnisher.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<unregisterItem set="method" line="309"><f a="trait:currItem:origItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></unregisterItem>
		<registerItem set="method" line="242"><f a="trait:origItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<c path="composure.core.ComposeItem"/>
</f></registerItem>
		<getItem set="method" line="239"><f a="trait">
	<d/>
	<c path="composure.core.ComposeItem"/>
</f></getItem>
		<testRules set="method" line="223"><f a="foundTrait:item:rules">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
	<e path="Bool"/>
</f></testRules>
		<getTrait set="method" line="206"><f a="foundTrait:item:addTrait">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<e path="composure.utilTraits.AddTrait"/>
	<d/>
</f></getTrait>
		<addTrait public="1" set="method" line="190"><f a="addTrait">
	<e path="composure.utilTraits.AddTrait"/>
	<e path="Void"/>
</f></addTrait>
		<onConcernedTraitRemoved set="method" line="169"><f a="trait:currItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onConcernedTraitRemoved>
		<onConcernedTraitAdded set="method" line="144"><f a="trait:origItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onConcernedTraitAdded>
		<_ignoreTraitChanges><e path="Bool"/></_ignoreTraitChanges>
		<_originalParents><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.core.ComposeGroup"/>
</c></_originalParents>
		<_originalItems><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.core.ComposeItem"/>
</c></_originalItems>
		<_traitToItems><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.core.ComposeItem"/>
</c></_traitToItems>
		<_addedTraits><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="Array"><d/></c>
</c></_addedTraits>
		<_foundTraits><c path="org.tbyrne.collections.UniqueList"><d/></c></_foundTraits>
		<_addTraits><c path="org.tbyrne.collections.UniqueList"><e path="composure.utilTraits.AddTrait"/></c></_addTraits>
		<_injector><c path="composure.injectors.Injector"/></_injector>
		<_addType><e path="composure.utilTraits.AddType"/></_addType>
		<set_searchAscendants set="method" line="105"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchAscendants>
		<searchAscendants public="1" set="set_searchAscendants"><e path="Bool"/></searchAscendants>
		<set_searchDescendants set="method" line="95"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchDescendants>
		<searchDescendants public="1" set="set_searchDescendants"><e path="Bool"/></searchDescendants>
		<set_searchSiblings set="method" line="85"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchSiblings>
		<searchSiblings public="1" set="set_searchSiblings"><e path="Bool"/></searchSiblings>
		<set_concernedTraitType set="method" line="70"><f a="value">
	<d/>
	<d/>
</f></set_concernedTraitType>
		<concernedTraitType public="1" set="set_concernedTraitType"><d/></concernedTraitType>
		<new public="1" set="method" line="126"><f a="?concernedTraitType:?addTraits:?addType:?searchSiblings:?searchDescendants:?searchAscendants">
	<d/>
	<c path="Array"><e path="composure.utilTraits.AddTrait"/></c>
	<e path="composure.utilTraits.AddType"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The Furnisher class is used to add traits to an item in response
 * to a certain type of trait being added to the item.<br/>
 * <br/>
 * This is very useful when creating interchangable libraries. For example,
 * when wanting to add a platform specific display trait to a items in the
 * presence of another trait:
 * <pre><code>
 * var furnisher:Furnisher = new Furnisher(RectangleInfo, [TType(HtmlRectangleDisplay)]);
 * stage.addTrait(furnisher);
 * </code></pre>
 * In this example, any item which has a RectangleInfo trait added to it (representing
 * a rectangle's position and size) will also get a HtmlRectangleDisplay trait added to
 * it. The HtmlRectangleDisplay object can then access the RectangleInfo's size and 
 * position properties using injection metadata. In this way, the display method for
 * all rectangles could be quickly and easily be swapped out for another display trait.
 * 
 * @author Tom Byrne]]></haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<enum path="composure.utilTraits.AddTrait" params="" file="../src/composure/utilTraits/Furnisher.hx" module="composure.utilTraits.Furnisher">
		<TType a="t:?rules">
			<c path="Class"><d/></c>
			<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
		</TType>
		<TInst a="t:?rules">
			<d/>
			<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
		</TInst>
		<TFact a="f:?rules">
			<f a="">
				<d/>
				<d/>
			</f>
			<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
		</TFact>
	</enum>
	<enum path="composure.utilTraits.AddRule" params="" file="../src/composure/utilTraits/Furnisher.hx" module="composure.utilTraits.Furnisher">
		<UnlessHas a="t"><c path="Class"><d/></c></UnlessHas>
		<IfHas a="t"><c path="Class"><d/></c></IfHas>
	</enum>
	<enum path="composure.utilTraits.AddType" params="" file="../src/composure/utilTraits/Furnisher.hx" module="composure.utilTraits.Furnisher">
		<traitSibling a="?adoptMatchedTrait"><e path="Bool"/></traitSibling>
		<traitItem/>
		<traitChild a="?adoptMatchedTrait"><e path="Bool"/></traitChild>
		<selfSibling a="?adoptMatchedTrait"><e path="Bool"/></selfSibling>
		<selfItem a="?adoptMatchedTrait"><e path="Bool"/></selfItem>
		<selfChild a="?adoptMatchedTrait"><e path="Bool"/></selfChild>
		<itemSibling a="item:?adoptMatchedTrait">
			<c path="composure.core.ComposeItem"/>
			<e path="Bool"/>
		</itemSibling>
		<itemChild a="group:?adoptMatchedTrait">
			<c path="composure.core.ComposeGroup"/>
			<e path="Bool"/>
		</itemChild>
		<item a="item:?adoptMatchedTrait">
			<c path="composure.core.ComposeItem"/>
			<e path="Bool"/>
		</item>
		<adoptItem a="newParent:?adoptMatchedTrait">
			<c path="composure.core.ComposeGroup"/>
			<e path="Bool"/>
		</adoptItem>
	</enum>
	<class path="composure.utilTraits.LazyTraitMap" params="MatchType" file="../src/composure/utilTraits/LazyTraitMap.hx">
		<returnInstance public="1" set="method" line="36"><f a="context:trait">
	<c path="composure.core.ComposeItem"/>
	<c path="composure.utilTraits.LazyTraitMap.MatchType"/>
	<e path="Void"/>
</f></returnInstance>
		<requestInstance public="1" set="method" line="21"><f a="context">
	<c path="composure.core.ComposeItem"/>
	<c path="composure.utilTraits.LazyTraitMap.MatchType"/>
</f></requestInstance>
		<_typeCreator><e path="composure.utilTraits.TypeCreator"><c path="composure.utilTraits.LazyTraitMap.MatchType"/></e></_typeCreator>
		<matchType public="1" set="null"><c path="Class"><c path="composure.utilTraits.LazyTraitMap.MatchType"/></c></matchType>
		<new public="1" set="method" line="15"><f a="matchType:typeCreator">
	<c path="Class"><c path="composure.utilTraits.LazyTraitMap.MatchType"/></c>
	<e path="composure.utilTraits.TypeCreator"><c path="composure.utilTraits.LazyTraitMap.MatchType"/></e>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<enum path="composure.utilTraits.TypeCreator" params="MatchType" file="../src/composure/utilTraits/LazyTraitMap.hx" module="composure.utilTraits.LazyTraitMap">
		<FInst a="trait:?addToContext">
			<d/>
			<e path="Bool"/>
		</FInst>
		<FFact a="factory"><f a=""><c path="composure.utilTraits.TypeCreator.MatchType"/></f></FFact>
		<FClass a="type:?args">
			<c path="Class"><c path="composure.utilTraits.TypeCreator.MatchType"/></c>
			<c path="Array"><d/></c>
		</FClass>
	</enum>
	<class path="composure.utilTraits.TraitTypeLimiter" params="" file="../src/composure/utilTraits/TraitTypeLimiter.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<attemptTransmit set="method" line="169"><f a="toTrait:fromTrait">
	<d/>
	<d/>
	<e path="Void"/>
</f></attemptTransmit>
		<reAddTrait set="method" line="157"><f a="item:added:removed">
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></reAddTrait>
		<onTraitRemoved set="method" line="143"><f a="trait:item">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onTraitRemoved>
		<onTraitAdded set="method" line="110"><f a="trait:item">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onTraitAdded>
		<checkTraits set="method" line="94"><f a=""><e path="Void"/></f></checkTraits>
		<reAddAll set="method" line="78"><f a=""><e path="Void"/></f></reAddAll>
		<setConcern public="1" set="method" line="62"><f a="traitType:?siblings:?descendants:?ascendants">
	<c path="Class"><d/></c>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setConcern>
		<_ignoreChanges><e path="Bool"/></_ignoreChanges>
		<_removed><c path="cmtc.ds.hash.ObjectHash">
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><d/></c>
</c></_removed>
		<_added><c path="cmtc.ds.hash.ObjectHash">
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><d/></c>
</c></_added>
		<added><e path="Bool"/></added>
		<injector><c path="composure.injectors.Injector"/></injector>
		<policy public="1"><e path="composure.utilTraits.LimitPolicy"/></policy>
		<set_maxCount set="method" line="26"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></set_maxCount>
		<maxCount public="1" set="set_maxCount"><c path="Int"/></maxCount>
		<new public="1" set="method" line="44"><f a="?traitType:?policy:?maxCount:?siblings:?descendants:?ascendants">
	<c path="Class"><d/></c>
	<e path="composure.utilTraits.LimitPolicy"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* TraitTypeLimiter is used to restrict the amount of a certain type of trait
 * which can be added to a certain item. It could be used, for example, to limit the
 * amount of IMatrixTransform traits on a certain item to 1.<br/>
 * If the initially added trait (i.e. the last one added before maxCount was reached)
 * implements ITransmittableTrait, then the removed trait will be passed into this
 * trait using the transmitFrom method, this allows the existing trait to copy over
 * information from the new trait.<br/>
 * Typically this class is used when the end user has control over trait structures
 * to enforce certain rules.
 * @author Tom Byrne]]></haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<enum path="composure.utilTraits.LimitPolicy" params="" file="../src/composure/utilTraits/TraitTypeLimiter.hx" module="composure.utilTraits.TraitTypeLimiter">
		<FirstInLastOut/>
		<FirstInFirstOut/>
	</enum>
	<class path="composure.utilTraits.ITransmittableTrait" params="" file="../src/composure/utilTraits/TraitTypeLimiter.hx" module="composure.utilTraits.TraitTypeLimiter" interface="1"><transmitFrom public="1" set="method"><f a="trait">
	<d/>
	<e path="Void"/>
</f></transmitFrom></class>
	<class path="composureTest.ClassIncluder" params="" file="../testSrc/composureTest/ClassIncluder.hx"><main set="method" line="14" static="1"><f a=""><e path="Void"/></f></main></class>
	<class path="haxe.FastCell" params="T" file="C:\Motion-Twin\haxe/std/haxe/FastList.hx" module="haxe.FastList">
		<next public="1"><c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c></next>
		<elt public="1"><c path="haxe.FastCell.T"/></elt>
		<new public="1" set="method" line="33"><f a="elt:next">
	<c path="haxe.FastCell.T"/>
	<c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastList" params="T" file="C:\Motion-Twin\haxe/std/haxe/FastList.hx">
		<toString public="1" set="method" line="156">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="138">
			<f a=""><t path="Iterator"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="107">
			<f a="v">
				<c path="haxe.FastList.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<isEmpty public="1" get="inline" set="null" line="99">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" get="inline" set="null" line="86">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<first public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<add public="1" get="inline" set="null" line="69">
			<f a="item">
				<c path="haxe.FastList.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the head of the list.</haxe_doc>
		</add>
		<head public="1"><c path="haxe.FastCell"><c path="haxe.FastList.T"/></c></head>
		<new public="1" set="method" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. A different class is created for each container used in platforms where it matters</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="C:\Motion-Twin\haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="54" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\Motion-Twin\haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams>
		<c path="Array"><d/></c>
		<meta><m n=":optional"/></meta>
	</customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="haxe.Serializer" params="" file="C:\Motion-Twin\haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="34" static="1">
			<e path="Bool"/>
			<haxe_doc>If the values you are serializing can contain
		circular references or objects repetitions, you should
		set USE_CACHE to true to prevent infinite loops.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="40" static="1">
			<e path="Bool"/>
			<haxe_doc>Use constructor indexes for enums instead of names.
		This is less reliable but more compact.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="42" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="436" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serialize a single value and return the string.</haxe_doc>
		</run>
		<serializeException public="1" set="method" line="417"><f a="e">
	<d/>
	<e path="Void"/>
</f></serializeException>
		<serialize public="1" set="method" line="158"><f a="v">
	<d/>
	<e path="Void"/>
</f></serialize>
		<serializeFields set="method" line="150"><f a="v">
	<unknown/>
	<e path="Void"/>
</f></serializeFields>
		<serializeRef set="method" line="113"><f a="v">
	<unknown/>
	<e path="Bool"/>
</f></serializeRef>
		<serializeString set="method" line="94"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></serializeString>
		<toString public="1" set="method" line="60"><f a=""><c path="String"/></f></toString>
		<useEnumIndex public="1"><e path="Bool"/></useEnumIndex>
		<useCache public="1"><e path="Bool"/></useCache>
		<scount><c path="Int"/></scount>
		<shash><c path="Hash"><c path="Int"/></c></shash>
		<cache><c path="Array"><d/></c></cache>
		<buf><c path="StringBuf"/></buf>
		<new public="1" set="method" line="51"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="haxe.TypeResolver" params="" file="C:\Motion-Twin\haxe/std/haxe/Unserializer.hx" module="haxe.Unserializer"><a>
	<resolveEnum set="method"><f a="name">
	<c path="String"/>
	<c path="Enum"><d/></c>
</f></resolveEnum>
	<resolveClass set="method"><f a="name">
	<c path="String"/>
	<c path="Class"><d/></c>
</f></resolveClass>
</a></typedef>
	<class path="haxe.Unserializer" params="" file="C:\Motion-Twin\haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="34" static="1"><t path="haxe.TypeResolver"/></DEFAULT_RESOLVER>
		<BASE64 line="36" static="1"><c path="String"/></BASE64>
		<CODES line="39" static="1"><c path="Array"><c path="Int"/></c></CODES>
		<initCodes set="method" line="41" static="1"><f a=""><c path="Array"><c path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="351" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserialize a single value and return it.</haxe_doc>
		</run>
		<unserialize public="1" set="method" line="151"><f a=""><d/></f></unserialize>
		<unserializeEnum set="method" line="139"><f a="edecl:tag">
	<c path="Enum"><unknown/></c>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserializeObject set="method" line="124"><f a="o">
	<a/>
	<e path="Void"/>
</f></unserializeObject>
		<readDigits set="method" line="99"><f a=""><c path="Int"/></f></readDigits>
		<get get="inline" set="null" line="95"><f a="p">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<getResolver public="1" set="method" line="91"><f a=""><t path="haxe.TypeResolver"/></f></getResolver>
		<setResolver public="1" set="method" line="81"><f a="r">
	<t path="haxe.TypeResolver"/>
	<e path="Void"/>
</f></setResolver>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<scache><c path="Array"><c path="String"/></c></scache>
		<cache><c path="Array"><d/></c></cache>
		<length><c path="Int"/></length>
		<pos><c path="Int"/></pos>
		<buf><c path="String"/></buf>
		<new public="1" set="method" line="64"><f a="buf">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\Motion-Twin\haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="259" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="291" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="340" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<getData public="1" get="inline" set="null" line="255"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<toHex public="1" set="method" line="241"><f a=""><c path="String"/></f></toHex>
		<toString public="1" set="method" line="218"><f a=""><c path="String"/></f></toString>
		<readString public="1" set="method" line="168"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<compare public="1" set="method" line="130"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<sub public="1" set="method" line="103"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<blit public="1" set="method" line="71"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<set public="1" get="inline" set="null" line="53"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" set="null"><c path="Int"/></length>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="C:\Motion-Twin\haxe/std/haxe/io/BytesData.hx"><c path="Array"><c path="Int"/></c></typedef>
	<enum path="haxe.io.Error" params="" file="C:\Motion-Twin\haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<class path="haxe.macro.Compiler" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Compiler.hx"><haxe_doc>All these methods can be called for compiler configuration macros.</haxe_doc></class>
	<typedef path="haxe.macro.Position" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><c path="Int"/></min>
	<max><c path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<enum path="haxe.macro.Constant" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<CType a="s"><c path="String"/></CType>
		<CString a="s"><c path="String"/></CString>
		<CRegexp a="r:opt">
			<c path="String"/>
			<c path="String"/>
		</CRegexp>
		<CInt a="v"><c path="String"/></CInt>
		<CIdent a="s"><c path="String"/></CIdent>
		<CFloat a="f"><c path="String"/></CFloat>
	</enum>
	<enum path="haxe.macro.Binop" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpXor/>
		<OpUShr/>
		<OpSub/>
		<OpShr/>
		<OpShl/>
		<OpOr/>
		<OpNotEq/>
		<OpMult/>
		<OpMod/>
		<OpLte/>
		<OpLt/>
		<OpInterval/>
		<OpGte/>
		<OpGt/>
		<OpEq/>
		<OpDiv/>
		<OpBoolOr/>
		<OpBoolAnd/>
		<OpAssignOp a="op"><e path="haxe.macro.Binop"/></OpAssignOp>
		<OpAssign/>
		<OpAnd/>
		<OpAdd/>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpNot/>
		<OpNegBits/>
		<OpNeg/>
		<OpIncrement/>
		<OpDecrement/>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprRequire" params="T" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<enum path="haxe.macro.ExprDef" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<EWhile a="econd:e:normalWhile">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<e path="Bool"/>
		</EWhile>
		<EVars a="vars"><c path="Array"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></c></EVars>
		<EUntyped a="e"><t path="haxe.macro.Expr"/></EUntyped>
		<EUnop a="op:postFix:e">
			<e path="haxe.macro.Unop"/>
			<e path="Bool"/>
			<t path="haxe.macro.Expr"/>
		</EUnop>
		<EType a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EType>
		<ETry a="e:catches">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c>
		</ETry>
		<EThrow a="e"><t path="haxe.macro.Expr"/></EThrow>
		<ETernary a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</ETernary>
		<ESwitch a="e:cases:edef">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</ESwitch>
		<EReturn a="?e"><t path="haxe.macro.Expr"/></EReturn>
		<EParenthesis a="e"><t path="haxe.macro.Expr"/></EParenthesis>
		<EObjectDecl a="fields"><c path="Array"><a>
	<field><c path="String"/></field>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c></EObjectDecl>
		<ENew a="t:params">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ENew>
		<EIn a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EIn>
		<EIf a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</EIf>
		<EFunction a="name:f">
			<t path="Null"><c path="String"/></t>
			<t path="haxe.macro.Function"/>
		</EFunction>
		<EFor a="it:expr">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EFor>
		<EField a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EField>
		<EDisplayNew a="t"><t path="haxe.macro.TypePath"/></EDisplayNew>
		<EDisplay a="e:isCall">
			<t path="haxe.macro.Expr"/>
			<e path="Bool"/>
		</EDisplay>
		<EContinue/>
		<EConst a="c"><e path="haxe.macro.Constant"/></EConst>
		<ECheckType a="e:t">
			<t path="haxe.macro.Expr"/>
			<e path="haxe.macro.ComplexType"/>
		</ECheckType>
		<ECast a="e:t">
			<t path="haxe.macro.Expr"/>
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
		</ECast>
		<ECall a="e:params">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ECall>
		<EBreak/>
		<EBlock a="exprs"><c path="Array"><t path="haxe.macro.Expr"/></c></EBlock>
		<EBinop a="op:e1:e2">
			<e path="haxe.macro.Binop"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EBinop>
		<EArrayDecl a="values"><c path="Array"><t path="haxe.macro.Expr"/></c></EArrayDecl>
		<EArray a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EArray>
	</enum>
	<enum path="haxe.macro.ComplexType" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPath a="p"><t path="haxe.macro.TypePath"/></TPath>
		<TParent a="t"><e path="haxe.macro.ComplexType"/></TParent>
		<TOptional a="t"><e path="haxe.macro.ComplexType"/></TOptional>
		<TFunction a="args:ret">
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<e path="haxe.macro.ComplexType"/>
		</TFunction>
		<TExtend a="p:fields">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Field"/></c>
		</TExtend>
		<TAnonymous a="fields"><c path="Array"><t path="haxe.macro.Field"/></c></TAnonymous>
	</enum>
	<typedef path="haxe.macro.TypePath" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</sub>
	<params><c path="Array"><e path="haxe.macro.TypeParam"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<enum path="haxe.macro.TypeParam" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPType a="t"><e path="haxe.macro.ComplexType"/></TPType>
		<TPExpr a="e"><t path="haxe.macro.Expr"/></TPExpr>
	</enum>
	<typedef path="haxe.macro.Function" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params><c path="Array"><a>
	<name><c path="String"/></name>
	<constraints><c path="Array"><e path="haxe.macro.ComplexType"/></c></constraints>
</a></c></params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value>
		<t path="Null"><t path="haxe.macro.Expr"/></t>
		<meta><m n=":optional"/></meta>
	</value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.Expr"/></c></params>
	<name><c path="String"/></name>
</a></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta>
		<t path="haxe.macro.Metadata"/>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</doc>
	<access>
		<c path="Array"><e path="haxe.macro.Access"/></c>
		<meta><m n=":optional"/></meta>
	</access>
</a></typedef>
	<enum path="haxe.macro.Access" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<AStatic/>
		<APublic/>
		<APrivate/>
		<AOverride/>
		<AInline/>
		<ADynamic/>
	</enum>
	<enum path="haxe.macro.FieldType" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<FVar a="t:?e">
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
			<t path="haxe.macro.Expr"/>
		</FVar>
		<FProp a="get:set:t:?e">
			<c path="String"/>
			<c path="String"/>
			<e path="haxe.macro.ComplexType"/>
			<t path="haxe.macro.Expr"/>
		</FProp>
		<FFun a="f"><t path="haxe.macro.Function"/></FFun>
	</enum>
	<typedef path="haxe.macro.TypeDefinition" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<name><c path="String"/></name>
	<constraints><c path="Array"><e path="haxe.macro.ComplexType"/></c></constraints>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.Metadata"/></meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern><e path="Bool"/></isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<enum path="haxe.macro.TypeDefKind" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TDStructure/>
		<TDEnum/>
		<TDClass a="?extend:?implement:?isInterface">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.TypePath"/></c>
			<e path="Bool"/>
		</TDClass>
	</enum>
	<class path="haxe.macro.Error" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<pos public="1"><t path="haxe.macro.Position"/></pos>
		<message public="1"><c path="String"/></message>
		<new public="1" set="method" line="213"><f a="m:p">
	<c path="String"/>
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>This error can be used to handle or produce compilation errors in macros.</haxe_doc>
	</class>
	<typedef path="haxe.macro.Ref" params="T" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<toString set="method"><f a=""><c path="String"/></f></toString>
	<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
</a></typedef>
	<enum path="haxe.macro.Type" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx">
		<TType a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.DefType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TType>
		<TMono a="t"><t path="haxe.macro.Ref"><t path="Null"><e path="haxe.macro.Type"/></t></t></TMono>
		<TLazy a="f"><f a=""><e path="haxe.macro.Type"/></f></TLazy>
		<TInst a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TInst>
		<TFun a="args:ret">
			<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c>
			<e path="haxe.macro.Type"/>
		</TFun>
		<TEnum a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.EnumType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TEnum>
		<TDynamic a="t"><t path="Null"><e path="haxe.macro.Type"/></t></TDynamic>
		<TAnonymous a="a"><t path="haxe.macro.Ref"><t path="haxe.macro.AnonType"/></t></TAnonymous>
	</enum>
	<typedef path="haxe.macro.AnonType" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a><fields><c path="Array"><t path="haxe.macro.ClassField"/></c></fields></a></typedef>
	<typedef path="haxe.macro.BaseType" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.ClassField" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.FieldKind"/></kind>
	<isPublic><e path="Bool"/></isPublic>
	<expr set="method"><f a=""><t path="Null"><e path="haxe.macro.TypedExpr"/></t></f></expr>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<enum path="haxe.macro.ClassKind" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<KTypeParameter/>
		<KNormal/>
		<KMacroType/>
		<KGenericInstance a="cl:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</KGenericInstance>
		<KGeneric/>
		<KExtension a="cl:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</KExtension>
		<KExpr a="expr"><t path="haxe.macro.Expr"/></KExpr>
	</enum>
	<typedef path="haxe.macro.ClassType" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<superClass><t path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></t></superClass>
	<statics><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></statics>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.ClassKind"/></kind>
	<isPrivate><e path="Bool"/></isPrivate>
	<isInterface><e path="Bool"/></isInterface>
	<isExtern><e path="Bool"/></isExtern>
	<interfaces><c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c></interfaces>
	<init><t path="Null"><e path="haxe.macro.TypedExpr"/></t></init>
	<fields><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></fields>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructor><t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></t></constructor>
</a></typedef>
	<typedef path="haxe.macro.EnumField" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<index><c path="Int"/></index>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.EnumType" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<names><c path="Array"><c path="String"/></c></names>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructs><c path="Hash"><t path="haxe.macro.EnumField"/></c></constructs>
</a></typedef>
	<typedef path="haxe.macro.DefType" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<remove set="method"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></remove>
	<has set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></has>
	<get set="method"><f a=""><t path="haxe.macro.Metadata"/></f></get>
	<add set="method"><f a="name:params:pos">
	<c path="String"/>
	<c path="Array"><t path="haxe.macro.Expr"/></c>
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></add>
</a></typedef>
	<enum path="haxe.macro.FieldKind" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<FVar a="read:write">
			<e path="haxe.macro.VarAccess"/>
			<e path="haxe.macro.VarAccess"/>
		</FVar>
		<FMethod a="k"><e path="haxe.macro.MethodKind"/></FMethod>
	</enum>
	<enum path="haxe.macro.VarAccess" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<AccResolve/>
		<AccRequire a="r"><c path="String"/></AccRequire>
		<AccNormal/>
		<AccNo/>
		<AccNever/>
		<AccInline/>
		<AccCall a="m"><c path="String"/></AccCall>
	</enum>
	<enum path="haxe.macro.MethodKind" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<MethNormal/>
		<MethMacro/>
		<MethInline/>
		<MethDynamic/>
	</enum>
	<enum path="haxe.macro.TypedExpr" params="" file="C:\Motion-Twin\haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"/>
	<typedef path="msignal.AnySignal" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal"><c path="msignal.Signal">
	<d/>
	<d/>
</c></typedef>
	<class path="msignal.Signal" params="TSlot:TListener" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx">
		<get_numListeners set="method" line="167"><f a=""><c path="Int"/></f></get_numListeners>
		<createSlot set="method" line="162">
			<f a="listener:?once:?priority">
				<c path="msignal.Signal.TListener"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<meta><m n="IgnoreCover"/></meta>
		</createSlot>
		<registrationPossible set="method" line="144"><f a="listener:once">
	<c path="msignal.Signal.TListener"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></registrationPossible>
		<registerListener set="method" line="128"><f a="listener:?once:?priority">
	<c path="msignal.Signal.TListener"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Signal.TSlot"/>
</f></registerListener>
		<removeAll public="1" set="method" line="123">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Unsubscribes all listeners from the signal.</haxe_doc>
		</removeAll>
		<remove public="1" set="method" line="111">
			<f a="listener">
				<c path="msignal.Signal.TListener"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Unsubscribes a listener from the signal.
	
	@param listener The listener to remove
	@return The removed listener slot</haxe_doc>
		</remove>
		<addOnceWithPriority public="1" set="method" line="100">
			<f a="listener:?priority">
				<c path="msignal.Signal.TListener"/>
				<c path="Int"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a one-time listener for this signal.
	The signal will remove the listener automatically the first time it is called,
	after the dispatch to all listeners is complete.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</addOnceWithPriority>
		<addWithPriority public="1" set="method" line="87">
			<f a="listener:?priority">
				<c path="msignal.Signal.TListener"/>
				<c path="Int"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a listener for the signal.
	After you successfully register an event listener,
	you cannot change its priority through additional calls to add().
	To change a listener's priority, you must first call remove().
	Then you can register the listener again with the new priority level.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</addWithPriority>
		<addOnce public="1" set="method" line="72">
			<f a="listener">
				<c path="msignal.Signal.TListener"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a one-time listener for this signal.
	The signal will remove the listener automatically the first time it is called,
	after the dispatch to all listeners is complete.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</addOnce>
		<add public="1" set="method" line="59">
			<f a="listener">
				<c path="msignal.Signal.TListener"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a listener for the signal.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</add>
		<priorityBased><e path="Bool"/></priorityBased>
		<slots><c path="msignal.SlotList">
	<c path="msignal.Signal.TSlot"/>
	<c path="msignal.Signal.TListener"/>
</c></slots>
		<numListeners public="1" get="get_numListeners" set="null">
			<c path="Int"/>
			<haxe_doc>The current number of listeners for the signal.</haxe_doc>
		</numListeners>
		<valueClasses public="1"><c path="Array"><d/></c></valueClasses>
		<new set="method" line="45"><f a="?valueClasses">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>A Signal manages a list of listeners, which are executed when the signal is 
dispatched.</haxe_doc>
	</class>
	<class path="msignal.Signal0" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal">
		<extends path="msignal.Signal">
			<c path="msignal.Slot0"/>
			<f a=""><e path="Void"/></f>
		</extends>
		<createSlot set="method" line="197" override="1"><f a="listener:?once:?priority">
	<f a=""><e path="Void"/></f>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Slot0"/>
</f></createSlot>
		<dispatch public="1" set="method" line="186">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Executes the signals listeners with no arguements.</haxe_doc>
		</dispatch>
		<new public="1" set="method" line="178"><f a=""><e path="Void"/></f></new>
		<haxe_doc>Signal that executes listeners with no arguments.</haxe_doc>
	</class>
	<class path="msignal.Signal1" params="TValue" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal">
		<extends path="msignal.Signal">
			<c path="msignal.Slot1"><c path="msignal.Signal1.TValue"/></c>
			<f a="">
				<c path="msignal.Signal1.TValue"/>
				<e path="Void"/>
			</f>
		</extends>
		<createSlot set="method" line="227" override="1"><f a="listener:?once:?priority">
	<f a="">
		<c path="msignal.Signal1.TValue"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Slot1"><c path="msignal.Signal1.TValue"/></c>
</f></createSlot>
		<dispatch public="1" set="method" line="216">
			<f a="value">
				<c path="msignal.Signal1.TValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Executes the signals listeners with one arguement.</haxe_doc>
		</dispatch>
		<new public="1" set="method" line="208"><f a="?type">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Signal that executes listeners with one arguments.</haxe_doc>
	</class>
	<class path="msignal.Signal2" params="TValue1:TValue2" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal">
		<extends path="msignal.Signal">
			<c path="msignal.Slot2">
				<c path="msignal.Signal2.TValue1"/>
				<c path="msignal.Signal2.TValue2"/>
			</c>
			<f a=":">
				<c path="msignal.Signal2.TValue1"/>
				<c path="msignal.Signal2.TValue2"/>
				<e path="Void"/>
			</f>
		</extends>
		<createSlot set="method" line="257" override="1"><f a="listener:?once:?priority">
	<f a=":">
		<c path="msignal.Signal2.TValue1"/>
		<c path="msignal.Signal2.TValue2"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Slot2">
		<c path="msignal.Signal2.TValue1"/>
		<c path="msignal.Signal2.TValue2"/>
	</c>
</f></createSlot>
		<dispatch public="1" set="method" line="246">
			<f a="value1:value2">
				<c path="msignal.Signal2.TValue1"/>
				<c path="msignal.Signal2.TValue2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Executes the signals listeners with two arguements.</haxe_doc>
		</dispatch>
		<new public="1" set="method" line="238"><f a="?type1:?type2">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Signal that executes listeners with two arguments.</haxe_doc>
	</class>
	<typedef path="msignal.AnySlot" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot"><c path="msignal.Slot">
	<d/>
	<d/>
</c></typedef>
	<class path="msignal.Slot" params="TSignal:TListener" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx">
		<set_listener set="method" line="91"><f a="value">
	<c path="msignal.Slot.TListener"/>
	<c path="msignal.Slot.TListener"/>
</f></set_listener>
		<remove public="1" set="method" line="76">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Removes the slot from its signal.</haxe_doc>
		</remove>
		<signal><c path="msignal.Slot.TSignal"/></signal>
		<enabled public="1">
			<e path="Bool"/>
			<haxe_doc>Whether the listener is called on execution. Defaults to true.</haxe_doc>
		</enabled>
		<priority public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The priority of this slot should be given in the execution order.
	An Signal will call higher numbers before lower ones.
	Defaults to 0.</haxe_doc>
		</priority>
		<once public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>Whether this slot is automatically removed after it has been used once.</haxe_doc>
		</once>
		<listener public="1" set="set_listener">
			<c path="msignal.Slot.TListener"/>
			<haxe_doc>The listener associated with this slot.
	Note: for hxcpp 2.10 this requires a getter method to compile</haxe_doc>
		</listener>
		<new set="method" line="64"><f a="signal:listener:?once:?priority">
	<c path="msignal.Slot.TSignal"/>
	<c path="msignal.Slot.TListener"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Defines the basic properties of a listener associated with a Signal.</haxe_doc>
	</class>
	<class path="msignal.Slot0" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot">
		<extends path="msignal.Slot">
			<c path="msignal.Signal0"/>
			<f a=""><e path="Void"/></f>
		</extends>
		<execute public="1" set="method" line="111">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Executes a listener with no arguments.</haxe_doc>
		</execute>
		<new public="1" set="method" line="103"><f a="signal:listener:?once:?priority">
	<c path="msignal.Signal0"/>
	<f a=""><e path="Void"/></f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>A slot that executes a listener with no arguments.</haxe_doc>
	</class>
	<class path="msignal.Slot1" params="TValue" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot">
		<extends path="msignal.Slot">
			<c path="msignal.Signal1"><c path="msignal.Slot1.TValue"/></c>
			<f a="">
				<c path="msignal.Slot1.TValue"/>
				<e path="Void"/>
			</f>
		</extends>
		<execute public="1" set="method" line="138">
			<f a="value1">
				<c path="msignal.Slot1.TValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Executes a listener with one argument.
	If <code>param</code> is not null, it overrides the value provided.]]></haxe_doc>
		</execute>
		<param public="1">
			<d/>
			<haxe_doc>Allows the slot to inject the argument to dispatch.</haxe_doc>
		</param>
		<new public="1" set="method" line="129"><f a="signal:listener:?once:?priority">
	<c path="msignal.Signal1"><c path="msignal.Slot1.TValue"/></c>
	<f a="">
		<c path="msignal.Slot1.TValue"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>A slot that executes a listener with one argument.</haxe_doc>
	</class>
	<class path="msignal.Slot2" params="TValue1:TValue2" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot">
		<extends path="msignal.Slot">
			<c path="msignal.Signal2">
				<c path="msignal.Slot2.TValue1"/>
				<c path="msignal.Slot2.TValue2"/>
			</c>
			<f a=":">
				<c path="msignal.Slot2.TValue1"/>
				<c path="msignal.Slot2.TValue2"/>
				<e path="Void"/>
			</f>
		</extends>
		<execute public="1" set="method" line="172">
			<f a="value1:value2">
				<c path="msignal.Slot2.TValue1"/>
				<c path="msignal.Slot2.TValue2"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Executes a listener with two arguments.
	If <code>param1</code> or <code>param2</code> is set, 
	they override the values provided.]]></haxe_doc>
		</execute>
		<param2 public="1">
			<d/>
			<haxe_doc>Allows the slot to inject the second argument to dispatch.</haxe_doc>
		</param2>
		<param1 public="1">
			<d/>
			<haxe_doc>Allows the slot to inject the first argument to dispatch.</haxe_doc>
		</param1>
		<new public="1" set="method" line="162"><f a="signal:listener:?once:?priority">
	<c path="msignal.Signal2">
		<c path="msignal.Slot2.TValue1"/>
		<c path="msignal.Slot2.TValue2"/>
	</c>
	<f a=":">
		<c path="msignal.Slot2.TValue1"/>
		<c path="msignal.Slot2.TValue2"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>A slot that executes a listener with two arguments.</haxe_doc>
	</class>
	<class path="msignal.SlotList" params="TSlot:TListener" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/SlotList.hx">
		<NIL public="1" static="1">
			<c path="msignal.SlotList">
				<d/>
				<d/>
			</c>
			<haxe_doc>Represents an empty list. Used as the list terminator.</haxe_doc>
		</NIL>
		<find public="1" set="method" line="240">
			<f a="listener">
				<c path="msignal.SlotList.TListener"/>
				<c path="msignal.SlotList.TSlot"/>
			</f>
			<haxe_doc>Retrieves the Slot associated with a supplied listener within the SlotList.
	@param   listener The Function being searched for
	@return  The ISlot in this list associated with the listener parameter through the ISlot.listener property.
			 Returns null if no such ISlot instance exists or the list is empty.</haxe_doc>
		</find>
		<contains public="1" set="method" line="220">
			<f a="listener">
				<c path="msignal.SlotList.TListener"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Determines whether the supplied listener Function is contained within this list</haxe_doc>
		</contains>
		<filterNot public="1" set="method" line="189">
			<f a="listener">
				<c path="msignal.SlotList.TListener"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Returns the slots in this list that do not contain the supplied listener.
	Note: assumes the listener is not repeated within the list.
	@param	listener The function to remove.
	@return A list consisting of all elements of this list that do not have listener.</haxe_doc>
		</filterNot>
		<insertWithPriority public="1" set="method" line="152"><f a="slot">
	<c path="msignal.SlotList.TSlot"/>
	<c path="msignal.SlotList">
		<c path="msignal.SlotList.TSlot"/>
		<c path="msignal.SlotList.TListener"/>
	</c>
</f></insertWithPriority>
		<append public="1" set="method" line="118">
			<f a="slot">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Appends a slot to this list.
	Note: appending is O(n). Where possible, prepend which is O(1).
	In some cases, many list items must be cloned to 
	avoid changing existing lists.
	@param	slot The item to be appended.
	@return	A list consisting of all elements of this list followed by slot.</haxe_doc>
		</append>
		<prepend public="1" set="method" line="105">
			<f a="slot">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Prepends a slot to this list.
	@param	slot The item to be prepended.
	@return	A list consisting of slot followed by all elements of this list.</haxe_doc>
		</prepend>
		<get_length set="method" line="79"><f a=""><c path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<c path="Int"/>
			<haxe_doc>The number of slots in the list.</haxe_doc>
		</length>
		<nonEmpty public="1"><e path="Bool"/></nonEmpty>
		<tail public="1"><c path="msignal.SlotList">
	<c path="msignal.SlotList.TSlot"/>
	<c path="msignal.SlotList.TListener"/>
</c></tail>
		<head public="1"><c path="msignal.SlotList.TSlot"/></head>
		<new public="1" set="method" line="49">
			<f a="head:?tail">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Creates and returns a new SlotList object.
	 *
	<p>A user never has to create a SlotList manually. 
	Use the <code>NIL</code> element to represent an empty list. 
	<code>NIL.prepend(value)</code> would create a list containing <code>value</code></p>.
	 *
	@param head The first slot in the list.
	@param tail A list containing all slots except head.]]></haxe_doc>
		</new>
	</class>
	<class path="org.tbyrne.collections.UniqueList" params="T" file="../src/org/tbyrne/collections/UniqueList.hx">
		<clear public="1" set="method" line="50"><f a=""><e path="Void"/></f></clear>
		<remove public="1" set="method" line="42"><f a="value">
	<c path="org.tbyrne.collections.UniqueList.T"/>
	<e path="Bool"/>
</f></remove>
		<containsItem public="1" set="method" line="39"><f a="value">
	<c path="org.tbyrne.collections.UniqueList.T"/>
	<e path="Bool"/>
</f></containsItem>
		<add public="1" set="method" line="31"><f a="value">
	<c path="org.tbyrne.collections.UniqueList.T"/>
	<e path="Bool"/>
</f></add>
		<first public="1" set="method" line="27"><f a=""><t path="Null"><c path="org.tbyrne.collections.UniqueList.T"/></t></f></first>
		<_length><c path="Int"/></_length>
		<list><c path="haxe.FastList"><c path="org.tbyrne.collections.UniqueList.T"/></c></list>
		<get_length set="method" line="18"><f a=""><c path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null"><c path="Int"/></length>
		<iterator public="1" set="method" line="14"><f a=""><t path="Iterator"><c path="org.tbyrne.collections.UniqueList.T"/></t></f></iterator>
		<new public="1" set="method" line="6"><f a="?list">
	<t path="Iterable"><c path="org.tbyrne.collections.UniqueList.T"/></t>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.tbyrne.logging.LogMsg" params="" file="../src/org/tbyrne/logging/LogMsg.hx">
		<toString public="1" set="method" line="24">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Used by trace when Logging hasn't been setup.</haxe_doc>
		</toString>
		<title public="1"><c path="String"/></title>
		<types public="1"><c path="Array"><c path="String"/></c></types>
		<message public="1"><c path="String"/></message>
		<id public="1"><c path="String"/></id>
		<new public="1" set="method" line="15"><f a="?message:?types:?title:?id">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.LogType" params="" file="../src/org/tbyrne/logging/LogMsg.hx" module="org.tbyrne.logging.LogMsg">
		<devInfo public="1" static="1"><c path="String"/></devInfo>
		<devWarning public="1" static="1"><c path="String"/></devWarning>
		<devError public="1" static="1"><c path="String"/></devError>
		<userInfo public="1" static="1"><c path="String"/></userInfo>
		<userWarning public="1" static="1"><c path="String"/></userWarning>
		<userError public="1" static="1"><c path="String"/></userError>
		<performanceWarning public="1" static="1"><c path="String"/></performanceWarning>
		<deprecationWarning public="1" static="1"><c path="String"/></deprecationWarning>
		<externalError public="1" static="1"><c path="String"/></externalError>
	</class>
</haxe>