<haxe>
	<class path="Array" params="T" file="C:\Motion-Twin\Haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="Class" params="T" file="C:\Motion-Twin\Haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="Date" params="" file="C:\Motion-Twin\Haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new date object.
	</haxe_doc>
		</new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="Enum" params="T" file="C:\Motion-Twin\Haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="EnumValue" params="" file="C:\Motion-Twin\Haxe/std/EnumValue.hx" extern="1"><haxe_doc>
	An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="Hash" params="T" file="C:\Motion-Twin\Haxe/std/Hash.hx" extern="1">
		<set public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="IntHash" params="T" file="C:\Motion-Twin\Haxe/std/IntHash.hx" extern="1">
		<set public="1" set="method">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.
</haxe_doc>
	</class>
	<class path="IntIter" params="" file="C:\Motion-Twin\Haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="List" params="T" file="C:\Motion-Twin\Haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="80">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="88">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="98">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="193">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="212">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="228">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<class path="Math" params="" file="C:\Motion-Twin\Haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="Reflect" params="" file="C:\Motion-Twin\Haxe/std/Reflect.hx" extern="1">
		<hasField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<getProperty public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Similar to field but also supports property (might be slower).
	</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Similar to setField but also supports property (might be slower).
	</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="Std" params="" file="C:\Motion-Twin\Haxe/std/Std.hx" extern="1">
		<is public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" set="method" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<enum path="Void" params="" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Motion-Twin\Haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="String" params="" file="C:\Motion-Twin\Haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="C:\Motion-Twin\Haxe/std/StringBuf.hx">
		<add public="1" get="inline" set="null" line="46">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="59">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="75">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="89">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="String"/></b>
		<new public="1" set="method" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="StringTools" params="" file="C:\Motion-Twin\Haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="87" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="98" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="105" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="114" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="122" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="161" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="172" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="194" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="219" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" set="method" line="230" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="253" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.
	</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="270" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="C:\Motion-Twin\Haxe/std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
		<haxe_doc>
	The diffent possible runtime types of a value.
	See [Type] for the haXe Reflection API.
</haxe_doc>
	</enum>
	<class path="Type" params="" file="C:\Motion-Twin\Haxe/std/Type.hx" extern="1">
		<getClass public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>
		Returns the list of all enum values that don't take any parameter.
	</haxe_doc>
		</allEnums>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="C:\Motion-Twin\Haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="54" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\Motion-Twin\Haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="haxe.Serializer" params="" file="C:\Motion-Twin\Haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="34" static="1">
			<e path="Bool"/>
			<haxe_doc>
		If the values you are serializing can contain
		circular references or objects repetitions, you should
		set USE_CACHE to true to prevent infinite loops.
	</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="40" static="1">
			<e path="Bool"/>
			<haxe_doc>
		Use constructor indexes for enums instead of names.
		This is less reliable but more compact.
	</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="42" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="416" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize a single value and return the string.
	</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="Hash"><c path="Int"/></c></shash>
		<scount><c path="Int"/></scount>
		<useCache public="1"><e path="Bool"/></useCache>
		<useEnumIndex public="1"><e path="Bool"/></useEnumIndex>
		<toString public="1" set="method" line="60"><f a=""><c path="String"/></f></toString>
		<serializeString set="method" line="94"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="113"><f a="v">
	<unknown/>
	<e path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="150"><f a="v">
	<unknown/>
	<e path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="158"><f a="v">
	<d/>
	<e path="Void"/>
</f></serialize>
		<serializeException public="1" set="method" line="397"><f a="e">
	<d/>
	<e path="Void"/>
</f></serializeException>
		<new public="1" set="method" line="51"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="haxe.StackItem" params="" file="C:\Motion-Twin\Haxe/std/haxe/Stack.hx" module="haxe.Stack">
		<Module a="m"><c path="String"/></Module>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<Lambda a="v"><c path="Int"/></Lambda>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<c path="Int"/>
		</FilePos>
		<CFunction/>
		<haxe_doc>
	Elements return by [Stack] methods.
</haxe_doc>
	</enum>
	<class path="haxe.Stack" params="" file="C:\Motion-Twin\Haxe/std/haxe/Stack.hx">
		<callStack public="1" set="method" line="46" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the call stack elements.
	</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="69" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		catched.
	</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="100" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of the stack as a printable string.
	</haxe_doc>
		</toString>
		<itemToString set="method" line="109" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<e path="Void"/>
</f></itemToString>
		<makeStack set="method" line="135" static="1"><f a="s">
	<unknown/>
	<unknown/>
</f></makeStack>
		<haxe_doc>
	Get informations about the call stack.
</haxe_doc>
	</class>
	<class path="haxe.TypeTools" params="" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/haxe/TypeTools.hx">
		<getClassNames public="1" set="method" line="40" static="1">
			<f a="value">
				<d/>
				<c path="List"><c path="String"/></c>
			</f>
			<haxe_doc>
	 * Returns a list of all the complete names of all the classes the passed value is an instance of. If the passed value itself
	 * is a class, this method will return a list containing its complete name and all its super classes. If you pass an instance
	 * of Sprite, for instance, this method will return a list containing "flash.display.Sprite",
	 * "flash.display.DisplayObjectContainer", "flash.display.InteractiveObject", "flash.display.DisplayObject" and
	 * "flash.events.EventDispatcher".
	 </haxe_doc>
		</getClassNames>
		<haxe_doc>
 * More advanced operations for reflection.
 </haxe_doc>
	</class>
	<typedef path="haxe.TypeResolver" params="" file="C:\Motion-Twin\Haxe/std/haxe/Unserializer.hx" module="haxe.Unserializer"><a>
	<resolveEnum set="method"><f a="name">
	<c path="String"/>
	<c path="Enum"><d/></c>
</f></resolveEnum>
	<resolveClass set="method"><f a="name">
	<c path="String"/>
	<c path="Class"><d/></c>
</f></resolveClass>
</a></typedef>
	<class path="haxe.Unserializer" params="" file="C:\Motion-Twin\Haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="34" static="1"><t path="haxe.TypeResolver"/></DEFAULT_RESOLVER>
		<BASE64 line="36" static="1"><c path="String"/></BASE64>
		<CODES line="39" static="1"><c path="Array"><c path="Int"/></c></CODES>
		<initCodes set="method" line="41" static="1"><f a=""><c path="Array"><c path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="351" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a single value and return it.
	</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><c path="Int"/></pos>
		<length><c path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" set="method" line="81"><f a="r">
	<t path="haxe.TypeResolver"/>
	<e path="Void"/>
</f></setResolver>
		<getResolver public="1" set="method" line="91"><f a=""><t path="haxe.TypeResolver"/></f></getResolver>
		<get get="inline" set="null" line="95"><f a="p">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<readDigits set="method" line="99"><f a=""><c path="Int"/></f></readDigits>
		<unserializeObject set="method" line="124"><f a="o">
	<a/>
	<e path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="139"><f a="edecl:tag">
	<c path="Enum"><unknown/></c>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="151"><f a=""><d/></f></unserialize>
		<new public="1" set="method" line="64"><f a="buf">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.exception.Exception" params="" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/haxe/exception/Exception.hx">
		<baseException public="1" get="getBaseException" set="null">
			<c path="haxe.exception.Exception"/>
			<haxe_doc>
	 * The initial exception that triggered the chain of exceptions resulting in this exception to be thrown. If this exception
	 * does not have any inner exceptions, this property is equal to this exception.
	 </haxe_doc>
		</baseException>
		<innerException public="1" set="null">
			<c path="haxe.exception.Exception"/>
			<haxe_doc>
	 * The exception that was thrown causing this exception to be thrown. If this exception does not have any inner exceptions,
	 * this property is null.
	 </haxe_doc>
		</innerException>
		<message public="1" set="null">
			<c path="String"/>
			<haxe_doc>
	 * The message associated with and describing this exception.
	 </haxe_doc>
		</message>
		<stackTrace public="1" set="null">
			<t path="Iterable"><e path="haxe.StackItem"/></t>
			<haxe_doc>
	 * The trace to the place where this exception was generated and thrown.
	 </haxe_doc>
		</stackTrace>
		<stackTraceArray>
			<c path="Array"><e path="haxe.StackItem"/></c>
			<haxe_doc>
	 * The same as the stackTrace property, only more accurately typed.
	 </haxe_doc>
		</stackTraceArray>
		<generateStackTrace get="inline" set="null" line="77">
			<f a="numberOfStackTraceShifts">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Generates the stacktrace. Is called in the constructor of this class. Calling this from somewhere else will result in a
	 * corrupted stacktrace.
	 </haxe_doc>
		</generateStackTrace>
		<getBaseException get="inline" set="null" line="90">
			<f a=""><c path="haxe.exception.Exception"/></f>
			<haxe_doc>
	 * Gets the base exception of this one.
	 </haxe_doc>
		</getBaseException>
		<toString set="method" line="97"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="60">
			<f a="?message:?innerException:?numberOfStackTraceShifts">
				<c path="String"/>
				<c path="haxe.exception.Exception"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new exception. Creating an exception automatically generates the corresponding stacktrace.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * General base class for exceptions.
 </haxe_doc>
	</class>
	<class path="haxe.exception.ArgumentNullException" params="" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/haxe/exception/ArgumentNullException.hx">
		<extends path="haxe.exception.Exception"/>
		<new public="1" set="method" line="36">
			<f a="?argumentName:?numberOfStackTraceShifts">
				<c path="String"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new argument null exception.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * An exception that can be thown when an argument is null, while a non-null value is expected.
 </haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="225" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="253" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="292" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="51"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" set="method" line="65"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" set="method" line="93"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="112"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" set="method" line="148"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="192"><f a=""><c path="String"/></f></toString>
		<toHex public="1" set="method" line="207"><f a=""><c path="String"/></f></toHex>
		<getData public="1" get="inline" set="null" line="221"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/BytesData.hx"><c path="Array"><c path="Int"/></c></typedef>
	<enum path="haxe.io.Error" params="" file="C:\Motion-Twin\Haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<class path="haxe.macro.Compiler" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Compiler.hx"><haxe_doc>
	All these methods can be called for compiler configuration macros.
</haxe_doc></class>
	<class path="haxe.macro.Context" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Context.hx"><haxe_doc>
	This is an API that can be used by macros implementations.
</haxe_doc></class>
	<typedef path="haxe.macro.Position" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><c path="Int"/></min>
	<max><c path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<enum path="haxe.macro.Constant" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<CType a="s"><c path="String"/></CType>
		<CString a="s"><c path="String"/></CString>
		<CRegexp a="r:opt">
			<c path="String"/>
			<c path="String"/>
		</CRegexp>
		<CInt a="v"><c path="String"/></CInt>
		<CIdent a="s"><c path="String"/></CIdent>
		<CFloat a="f"><c path="String"/></CFloat>
	</enum>
	<enum path="haxe.macro.Binop" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpXor/>
		<OpUShr/>
		<OpSub/>
		<OpShr/>
		<OpShl/>
		<OpOr/>
		<OpNotEq/>
		<OpMult/>
		<OpMod/>
		<OpLte/>
		<OpLt/>
		<OpInterval/>
		<OpGte/>
		<OpGt/>
		<OpEq/>
		<OpDiv/>
		<OpBoolOr/>
		<OpBoolAnd/>
		<OpAssignOp a="op"><e path="haxe.macro.Binop"/></OpAssignOp>
		<OpAssign/>
		<OpAnd/>
		<OpAdd/>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpNot/>
		<OpNegBits/>
		<OpNeg/>
		<OpIncrement/>
		<OpDecrement/>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprRequire" params="T" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<enum path="haxe.macro.ExprDef" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<EWhile a="econd:e:normalWhile">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<e path="Bool"/>
		</EWhile>
		<EVars a="vars"><c path="Array"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></c></EVars>
		<EUntyped a="e"><t path="haxe.macro.Expr"/></EUntyped>
		<EUnop a="op:postFix:e">
			<e path="haxe.macro.Unop"/>
			<e path="Bool"/>
			<t path="haxe.macro.Expr"/>
		</EUnop>
		<EType a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EType>
		<ETry a="e:catches">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c>
		</ETry>
		<EThrow a="e"><t path="haxe.macro.Expr"/></EThrow>
		<ETernary a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</ETernary>
		<ESwitch a="e:cases:edef">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</ESwitch>
		<EReturn a="?e"><t path="haxe.macro.Expr"/></EReturn>
		<EParenthesis a="e"><t path="haxe.macro.Expr"/></EParenthesis>
		<EObjectDecl a="fields"><c path="Array"><a>
	<field><c path="String"/></field>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c></EObjectDecl>
		<ENew a="t:params">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ENew>
		<EIn a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EIn>
		<EIf a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</EIf>
		<EFunction a="name:f">
			<t path="Null"><c path="String"/></t>
			<t path="haxe.macro.Function"/>
		</EFunction>
		<EFor a="it:expr">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EFor>
		<EField a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EField>
		<EDisplayNew a="t"><t path="haxe.macro.TypePath"/></EDisplayNew>
		<EDisplay a="e:isCall">
			<t path="haxe.macro.Expr"/>
			<e path="Bool"/>
		</EDisplay>
		<EContinue/>
		<EConst a="c"><e path="haxe.macro.Constant"/></EConst>
		<ECheckType a="e:t">
			<t path="haxe.macro.Expr"/>
			<e path="haxe.macro.ComplexType"/>
		</ECheckType>
		<ECast a="e:t">
			<t path="haxe.macro.Expr"/>
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
		</ECast>
		<ECall a="e:params">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ECall>
		<EBreak/>
		<EBlock a="exprs"><c path="Array"><t path="haxe.macro.Expr"/></c></EBlock>
		<EBinop a="op:e1:e2">
			<e path="haxe.macro.Binop"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EBinop>
		<EArrayDecl a="values"><c path="Array"><t path="haxe.macro.Expr"/></c></EArrayDecl>
		<EArray a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EArray>
	</enum>
	<enum path="haxe.macro.ComplexType" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPath a="p"><t path="haxe.macro.TypePath"/></TPath>
		<TParent a="t"><e path="haxe.macro.ComplexType"/></TParent>
		<TOptional a="t"><e path="haxe.macro.ComplexType"/></TOptional>
		<TFunction a="args:ret">
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<e path="haxe.macro.ComplexType"/>
		</TFunction>
		<TExtend a="p:fields">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Field"/></c>
		</TExtend>
		<TAnonymous a="fields"><c path="Array"><t path="haxe.macro.Field"/></c></TAnonymous>
	</enum>
	<typedef path="haxe.macro.TypePath" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub><t path="Null"><c path="String"/></t></sub>
	<params><c path="Array"><e path="haxe.macro.TypeParam"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<enum path="haxe.macro.TypeParam" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPType a="t"><e path="haxe.macro.ComplexType"/></TPType>
		<TPExpr a="e"><t path="haxe.macro.Expr"/></TPExpr>
	</enum>
	<typedef path="haxe.macro.Function" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params><c path="Array"><a>
	<name><c path="String"/></name>
	<constraints><c path="Array"><e path="haxe.macro.ComplexType"/></c></constraints>
</a></c></params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value><t path="Null"><t path="haxe.macro.Expr"/></t></value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.Expr"/></c></params>
	<name><c path="String"/></name>
</a></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.Metadata"/></meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc><t path="Null"><c path="String"/></t></doc>
	<access><c path="Array"><e path="haxe.macro.Access"/></c></access>
</a></typedef>
	<enum path="haxe.macro.Access" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<AStatic/>
		<APublic/>
		<APrivate/>
		<AOverride/>
		<AInline/>
		<ADynamic/>
	</enum>
	<enum path="haxe.macro.FieldType" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<FVar a="t:?e">
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
			<t path="haxe.macro.Expr"/>
		</FVar>
		<FProp a="get:set:t:?e">
			<c path="String"/>
			<c path="String"/>
			<e path="haxe.macro.ComplexType"/>
			<t path="haxe.macro.Expr"/>
		</FProp>
		<FFun a="f"><t path="haxe.macro.Function"/></FFun>
	</enum>
	<typedef path="haxe.macro.TypeDefinition" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<name><c path="String"/></name>
	<constraints><c path="Array"><e path="haxe.macro.ComplexType"/></c></constraints>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.Metadata"/></meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern><e path="Bool"/></isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<enum path="haxe.macro.TypeDefKind" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TDStructure/>
		<TDEnum/>
		<TDClass a="?extend:?implement:?isInterface">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.TypePath"/></c>
			<e path="Bool"/>
		</TDClass>
	</enum>
	<class path="haxe.macro.Error" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<message public="1"><c path="String"/></message>
		<pos public="1"><t path="haxe.macro.Position"/></pos>
		<new public="1" set="method" line="209"><f a="m:p">
	<c path="String"/>
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	This error can be used to handle or produce compilation errors in macros.
</haxe_doc>
	</class>
	<typedef path="haxe.macro.Ref" params="T" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<toString set="method"><f a=""><c path="String"/></f></toString>
	<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
</a></typedef>
	<enum path="haxe.macro.Type" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx">
		<TType a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.DefType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TType>
		<TMono a="t"><t path="haxe.macro.Ref"><t path="Null"><e path="haxe.macro.Type"/></t></t></TMono>
		<TLazy a="f"><f a=""><e path="haxe.macro.Type"/></f></TLazy>
		<TInst a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TInst>
		<TFun a="args:ret">
			<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c>
			<e path="haxe.macro.Type"/>
		</TFun>
		<TEnum a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.EnumType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TEnum>
		<TDynamic a="t"><t path="Null"><e path="haxe.macro.Type"/></t></TDynamic>
		<TAnonymous a="a"><t path="haxe.macro.Ref"><t path="haxe.macro.AnonType"/></t></TAnonymous>
	</enum>
	<typedef path="haxe.macro.AnonType" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a><fields><c path="Array"><t path="haxe.macro.ClassField"/></c></fields></a></typedef>
	<typedef path="haxe.macro.BaseType" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.ClassField" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.FieldKind"/></kind>
	<isPublic><e path="Bool"/></isPublic>
	<expr set="method"><f a=""><t path="Null"><e path="haxe.macro.TypedExpr"/></t></f></expr>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<enum path="haxe.macro.ClassKind" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<KTypeParameter/>
		<KNormal/>
		<KMacroType/>
		<KGenericInstance a="cl:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</KGenericInstance>
		<KGeneric/>
		<KExtension a="cl:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</KExtension>
		<KExpr a="expr"><t path="haxe.macro.Expr"/></KExpr>
	</enum>
	<typedef path="haxe.macro.ClassType" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<superClass><t path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></t></superClass>
	<statics><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></statics>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.ClassKind"/></kind>
	<isPrivate><e path="Bool"/></isPrivate>
	<isInterface><e path="Bool"/></isInterface>
	<isExtern><e path="Bool"/></isExtern>
	<interfaces><c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c></interfaces>
	<init><t path="Null"><e path="haxe.macro.TypedExpr"/></t></init>
	<fields><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></fields>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructor><t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></t></constructor>
</a></typedef>
	<typedef path="haxe.macro.EnumField" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<index><c path="Int"/></index>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.EnumType" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<names><c path="Array"><c path="String"/></c></names>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructs><c path="Hash"><t path="haxe.macro.EnumField"/></c></constructs>
</a></typedef>
	<typedef path="haxe.macro.DefType" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<remove set="method"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></remove>
	<has set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></has>
	<get set="method"><f a=""><t path="haxe.macro.Metadata"/></f></get>
	<add set="method"><f a="name:params:pos">
	<c path="String"/>
	<c path="Array"><t path="haxe.macro.Expr"/></c>
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></add>
</a></typedef>
	<enum path="haxe.macro.FieldKind" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<FVar a="read:write">
			<e path="haxe.macro.VarAccess"/>
			<e path="haxe.macro.VarAccess"/>
		</FVar>
		<FMethod a="k"><e path="haxe.macro.MethodKind"/></FMethod>
	</enum>
	<enum path="haxe.macro.VarAccess" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<AccResolve/>
		<AccRequire a="r"><c path="String"/></AccRequire>
		<AccNormal/>
		<AccNo/>
		<AccNever/>
		<AccInline/>
		<AccCall a="m"><c path="String"/></AccCall>
	</enum>
	<enum path="haxe.macro.MethodKind" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<MethNormal/>
		<MethMacro/>
		<MethInline/>
		<MethDynamic/>
	</enum>
	<enum path="haxe.macro.TypedExpr" params="" file="C:\Motion-Twin\Haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"/>
	<class path="hsl.haxe.Bond" params="" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/hsl/haxe/Bond.hx">
		<halted public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether the bond has been halted (true) or not (false). See the halt method for more information.
	 </haxe_doc>
		</halted>
		<willDestroyOnUse>
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether the bond will be destroyed right after it is used (true) or not (false).
	 </haxe_doc>
		</willDestroyOnUse>
		<destroy public="1" set="method" line="58">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Destroys the bond. The signaler that created this bond will no longer notify listeners through it. Bond cannot be
	 * "undestroyed". To temporary suspend the bond from notifying the associated listener, use the halt method.
	 </haxe_doc>
		</destroy>
		<destroyOnUse public="1" set="method" line="65">
			<f a=""><c path="hsl.haxe.Bond"/></f>
			<haxe_doc>
	 * Destroys the bond right after it is used. Whether this bond has already been used at the moment this method is called does
	 * not matter: the bond will be destroyed on its first use after this method has been called. This method returns this bond
	 * itself.
	 </haxe_doc>
		</destroyOnUse>
		<halt public="1" get="inline" set="null" line="73">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Halts the bond. The bond will ignore any calls, and will not notify any listeners, until the resume method is called. If
	 * the bond was already halted, calling this method has no effect.
	 </haxe_doc>
		</halt>
		<resume public="1" get="inline" set="null" line="80">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Resumes the bond, after it has been halted by calling the halt method. If the bond was not halted, calling this method has
	 * no effect. See the halt method for more information.
	 </haxe_doc>
		</resume>
		<new public="1" set="method" line="48">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Creates a new bond.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A bond represents the connection between a signaler and a listener. Bonds are created when listeners add themselves to a
 * signaler.
 * 
 * Bonds are used internally, and can be ignored in common cases. However, sometimes it is useful for listeners to store the
 * bond in a variable. Doing so allows you to halt and resume the bond, and destroy it easily.
 </haxe_doc>
	</class>
	<class path="hsl.haxe.Signaler" params="Datatype" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/hsl/haxe/Signaler.hx" interface="1">
		<isListenedTo public="1" get="getIsListenedTo" set="null">
			<e path="Bool"/>
			<haxe_doc><![CDATA[
	 * Indicates whether the signaler is listened to by at least one listener.
	 * 
	 * This property can be used for speed optimizations. If a signaler is not listened to, its subject does not have to
	 * calculate a value if that value will only be sent in a signal.
	 * 
	 * In this example the "Ball" class only calculates the distance if a listener is added to the signaler:
	 * <pre>
	 * package;
	 * import hsl.haxe.direct.DirectSignaler;
	 * import hsl.haxe.Signaler;
	 * class Ball {
	 * 	public var distanceUpdatedSignaler(default, null):DirectSignaler&lt;Float&gt;;
	 * 	public function new():Void {
	 * 		distanceUpdatedSignaler = new DirectSignaler(this);
	 * 	}
	 * 	public function move(x:Float, y:Float):Void {
	 * 		if (distanceUpdatedSignaler.isListenedTo) {
	 * 			var distance:Float = Math.sqrt(x * x + y * y);
	 * 			distanceUpdatedSignaler.dispatch(distance);
	 * 		}
	 * 	}
	 * }
	 * </pre>
	 ]]></haxe_doc>
		</isListenedTo>
		<subject public="1" set="null">
			<t path="hsl.haxe.Subject"/>
			<haxe_doc>
	 * The subject this signaler belongs to.
	 </haxe_doc>
		</subject>
		<addBubblingTarget public="1" set="method">
			<f a="value">
				<c path="hsl.haxe.Signaler"><c path="hsl.haxe.Signaler.Datatype"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Adds a bubbling target to the signaler. The signaler will bubble to this bubbling target in bubbling processes.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, or as3-signals by Robert Penner: those systems do not have an
	 * equivalent to this method, as they don't allow you to manually define where events/signals bubble to.
	 * </li></ul>
	 ]]></haxe_doc>
		</addBubblingTarget>
		<addNotificationTarget public="1" set="method">
			<f a="value">
				<c path="hsl.haxe.Signaler"><e path="Void"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Adds a notification target to the signaler. The signaler will notify to this notification target in bubbling processes,
	 * however, the data inside the signal will not be passed to this notification target.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, or as3-signals by Robert Penner: those systems do not have an
	 * equivalent to this method, as they don't allow you to manually define where events/signals bubble to.
	 * </li></ul>
	 ]]></haxe_doc>
		</addNotificationTarget>
		<bind public="1" set="method">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.Signaler.Datatype"/>
					<d/>
				</f>
				<c path="hsl.haxe.Bond"/>
			</f>
			<haxe_doc><![CDATA[
	 * Binds this signaler to a listener function that accepts an argument of the datatype of this signaler, and returns nothing.
	 * Returns the bond between the signaler. The bond can be removed by calling either the unbind method of the signaler, or the
	 * destroy method of the returned bond.
	 * 
	 * <ul><li>
	 * If you are familiar with jQuery: this method is similar to the "bind" method of that library.
	 * </li><li>
	 * If you are familiar with as3-signals by Robert Penner: this method is similar to the "add" method of that library.
	 * </li><li>
	 * If you are familiar with events in ActionScript 3.0: this method is similar to the "addEventListener" method of that
	 * system, though the bindAdvanced method of this library has more similarities to addEventListener.
	 * </li></ul>
	 ]]></haxe_doc>
		</bind>
		<bindAdvanced public="1" set="method">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.Signal"><c path="hsl.haxe.Signaler.Datatype"/></c>
					<d/>
				</f>
				<c path="hsl.haxe.Bond"/>
			</f>
			<haxe_doc><![CDATA[
	 * Binds this signaler to a listener function that accepts a signal, and returns nothing. Returns the bond between the
	 * signaler. The bond can be removed by calling either the unbindAdvanced method of the signaler, or the destroy method of
	 * the returned bond.
	 * 
	 * <ul><li>
	 * If you are familiar with jQuery: this method is similar to the "bind" method of that library.
	 * </li><li>
	 * If you are familiar with as3-signals by Robert Penner: this method is similar to the "add" method of that library, though
	 * the bind method of this library has more similarities to add.
	 * </li><li>
	 * If you are familiar with events in ActionScript 3.0: this method is similar to the "addEventListener" method of that
	 * system.
	 * </li></ul>
	 ]]></haxe_doc>
		</bindAdvanced>
		<bindVoid public="1" set="method">
			<f a="listener">
				<f a=""><d/></f>
				<c path="hsl.haxe.Bond"/>
			</f>
			<haxe_doc><![CDATA[
	 * Binds this signaler to a listener function that accepts nothing, and returns nothing. Returns the bond between the
	 * signaler. The bond can be removed by calling either the unbindVoid method of the signaler, or the destroy method of the
	 * returned bond.
	 * 
	 * <ul><li>
	 * If you are familiar with jQuery: this method is similar to the "bind" method of that library.
	 * </li><li>
	 * If you are familiar with as3-signals by Robert Penner: this method is similar to the "add" method of that library, though
	 * the bind method of this library has more similarities to add.
	 * </li><li>
	 * If you are familiar with events in ActionScript 3.0: this method is similar to the "addEventListener" method of that
	 * system, though the bindAdvanced method of this library has more similarities to addEventListener.
	 * </li></ul>
	 ]]></haxe_doc>
		</bindVoid>
		<dispatch public="1" set="method">
			<f a="?data:?origin:?positionInformation">
				<c path="hsl.haxe.Signaler.Datatype"/>
				<t path="hsl.haxe.Subject"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Dispatches a signal, containing the passed data. All the listeners that are listening to this signaler will be notified.
	 * The signal will bubble to all of the bubbling targets that were added to this signaler. This method may only be called
	 * by the subject of the signaler.
	 </haxe_doc>
		</dispatch>
		<getIsListenedTo set="method"><f a=""><e path="Bool"/></f></getIsListenedTo>
		<removeBubblingTarget public="1" set="method">
			<f a="value">
				<c path="hsl.haxe.Signaler"><c path="hsl.haxe.Signaler.Datatype"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes a bubbling target from the signaler. The signaler will stop bubbling to this bubbling target. If the signaler
	 * does not have the passed value as a bubbling target, calling this method has no effect.
	 </haxe_doc>
		</removeBubblingTarget>
		<removeNotificationTarget public="1" set="method">
			<f a="value">
				<c path="hsl.haxe.Signaler"><e path="Void"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes a notification target from the signaler. The signaler will stop notifying this notification target. If the
	 * signaler does not have the passed value as a notification target, calling this method has no effect.
	 </haxe_doc>
		</removeNotificationTarget>
		<unbind public="1" set="method">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.Signaler.Datatype"/>
					<d/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removed the bond between this signaler and a listener. If such bond does not exist, calling this method has no effect.
	 </haxe_doc>
		</unbind>
		<unbindAdvanced public="1" set="method">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.Signal"><c path="hsl.haxe.Signaler.Datatype"/></c>
					<d/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removed the bond between this signaler and a listener. If such bond does not exist, calling this method has no effect.
	 </haxe_doc>
		</unbindAdvanced>
		<unbindVoid public="1" set="method">
			<f a="listener">
				<f a=""><d/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removed the bond between this signaler and a listener. If such bond does not exist, calling this method has no effect.
	 </haxe_doc>
		</unbindVoid>
		<haxe_doc><![CDATA[
 * A signalers is a tool, used by a subject to notify its environment (listeners). Subjects create their signalers, usually in
 * their constructors. Listeners add themselves to signalers by calling one of the binding methods.
 * 
 * <ul><li>
 * If you are familiar with as3-signals by Robert Penner: signalers are similar to "signals" in that library.
 * </li><li>
 * If you are familiar with events in ActionScript 3.0: signalers have some similarities to "event dispatchers" in that system.
 * There is one major difference, though: an event dispatcher can dispatch events of different event types; but in this library
 * each type of signal has its own signaler.
 * </li></ul>
 ]]></haxe_doc>
	</class>
	<class path="hsl.haxe.DirectSignaler" params="Datatype" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx">
		<implements path="hsl.haxe.Signaler"><c path="hsl.haxe.DirectSignaler.Datatype"/></implements>
		<bubblingTargets><c path="List"><c path="hsl.haxe.Signaler"><c path="hsl.haxe.DirectSignaler.Datatype"/></c></c></bubblingTargets>
		<isListenedTo public="1" get="getIsListenedTo" set="null"><e path="Bool"/></isListenedTo>
		<notificationTargets><c path="List"><c path="hsl.haxe.Signaler"><e path="Void"/></c></c></notificationTargets>
		<rejectNullData><e path="Bool"/></rejectNullData>
		<sentinel><c path="hsl.haxe._DirectSignaler.SentinelBond"><c path="hsl.haxe.DirectSignaler.Datatype"/></c></sentinel>
		<subject public="1" set="null"><t path="hsl.haxe.Subject"/></subject>
		<subjectClassNames>
			<c path="List"><c path="String"/></c>
			<haxe_doc>
	 * The fully qualified class names of the subject.
	 </haxe_doc>
		</subjectClassNames>
		<addBubblingTarget public="1" set="method" line="64"><f a="value">
	<c path="hsl.haxe.Signaler"><c path="hsl.haxe.DirectSignaler.Datatype"/></c>
	<e path="Void"/>
</f></addBubblingTarget>
		<addNotificationTarget public="1" set="method" line="70"><f a="value">
	<c path="hsl.haxe.Signaler"><e path="Void"/></c>
	<e path="Void"/>
</f></addNotificationTarget>
		<bind public="1" set="method" line="76"><f a="listener">
	<f a="">
		<c path="hsl.haxe.DirectSignaler.Datatype"/>
		<d/>
	</f>
	<c path="hsl.haxe.Bond"/>
</f></bind>
		<bindAdvanced public="1" set="method" line="86"><f a="listener">
	<f a="">
		<c path="hsl.haxe.Signal"><c path="hsl.haxe.DirectSignaler.Datatype"/></c>
		<d/>
	</f>
	<c path="hsl.haxe.Bond"/>
</f></bindAdvanced>
		<bindVoid public="1" set="method" line="96"><f a="listener">
	<f a=""><d/></f>
	<c path="hsl.haxe.Bond"/>
</f></bindVoid>
		<bubble get="inline" set="null" line="106"><f a="data:origin">
	<c path="hsl.haxe.DirectSignaler.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<e path="Void"/>
</f></bubble>
		<dispatch public="1" set="method" line="121"><f a="?data:?origin:?positionInformation">
	<c path="hsl.haxe.DirectSignaler.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></dispatch>
		<getIsListenedTo set="method" line="162"><f a=""><e path="Bool"/></f></getIsListenedTo>
		<getOrigin get="inline" set="null" line="168">
			<f a="origin">
				<t path="hsl.haxe.Subject"/>
				<t path="hsl.haxe.Subject"/>
			</f>
			<haxe_doc>
	 * Returns the passed origin if it is not null. Returns the subject of this signaler if the passed origin is null.
	 </haxe_doc>
		</getOrigin>
		<verifyCaller set="method" line="188">
			<f a="positionInformation">
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Checks whether the class name inside the passed position information equals the class name of the subject of this
	 * signaler. Used in the dispatch method, as that method may only be called by the subject.
	 * 
	 * Two notes.
	 * One, by using this method you check whether the caller is of the same type as the subject, which does not necessarily mean
	 * it's the same instance. This is the expected behavior, as it is consistent with private members.
	 * Two, one could hack his or her way around this check. How to do this should be obvious. The check is not designed to be
	 * unhackable; rather it is designed to prevent developers from accidentally misapplying HSL. Nicolas Cannasse once said
	 * "everything should be made accessible, if you know what you're doing".
	 </haxe_doc>
		</verifyCaller>
		<removeBubblingTarget public="1" set="method" line="200"><f a="value">
	<c path="hsl.haxe.Signaler"><c path="hsl.haxe.DirectSignaler.Datatype"/></c>
	<e path="Void"/>
</f></removeBubblingTarget>
		<removeNotificationTarget public="1" set="method" line="205"><f a="value">
	<c path="hsl.haxe.Signaler"><e path="Void"/></c>
	<e path="Void"/>
</f></removeNotificationTarget>
		<unbind public="1" set="method" line="215"><f a="listener">
	<f a="">
		<c path="hsl.haxe.DirectSignaler.Datatype"/>
		<d/>
	</f>
	<e path="Void"/>
</f></unbind>
		<unbindAdvanced public="1" set="method" line="218"><f a="listener">
	<f a="">
		<c path="hsl.haxe.Signal"><c path="hsl.haxe.DirectSignaler.Datatype"/></c>
		<d/>
	</f>
	<e path="Void"/>
</f></unbindAdvanced>
		<unbindVoid public="1" set="method" line="221"><f a="listener">
	<f a=""><d/></f>
	<e path="Void"/>
</f></unbindVoid>
		<new public="1" set="method" line="54">
			<f a="subject:?rejectNullData">
				<t path="hsl.haxe.Subject"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new direct signaler.
	 * 
	 * The passed subject will be used as the subject of this signaler. Only the subject is allowed to call the dispatch method.
	 * Signals dispatched by this signaler will have the subject as current target, and in some cases as origin.
	 * 
	 * If the reject null data flag is set, the signaler will throw an exception if the subject attempts to dispatch a signal
	 * with null as data, or the the signaler is about to bubble a signal that contains null as data.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A signaler that dispatches signals directly.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.LinkedBond" params="Datatype" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<extends path="hsl.haxe.Bond"/>
		<destroyed><e path="Bool"/></destroyed>
		<next><c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.LinkedBond.Datatype"/></c></next>
		<previous><c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.LinkedBond.Datatype"/></c></previous>
		<callListener public="1" set="method" line="244">
			<f a="data:currentTarget:origin:propagationStatus">
				<c path="hsl.haxe._DirectSignaler.LinkedBond.Datatype"/>
				<t path="hsl.haxe.Subject"/>
				<t path="hsl.haxe.Subject"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Calls the listener stored inside. Classes that extend this one should override this method.
	 </haxe_doc>
		</callListener>
		<determineEquals set="method" line="251">
			<f a="value">
				<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.LinkedBond.Datatype"/></c>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Determines whether the passed bond equals this one. Returns true if they are equal; false otherwise. Classes that extend
	 * this one should override this method.
	 </haxe_doc>
		</determineEquals>
		<destroy public="1" set="method" line="254" override="1"><f a=""><e path="Void"/></f></destroy>
		<unlink get="inline" set="null" line="261"><f a=""><e path="Void"/></f></unlink>
		<new public="1" set="method" line="234"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * A doubly linked bond. The bond has a reference to the next and the previous bond in the list.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.SentinelBond" params="Datatype" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<extends path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.SentinelBond.Datatype"/></extends>
		<isConnected public="1" get="getIsConnected" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether this sentinel is connected to other bonds (true), or not (false).
	 </haxe_doc>
		</isConnected>
		<add public="1" get="inline" set="null" line="291">
			<f a="value">
				<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.SentinelBond.Datatype"/></c>
				<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.SentinelBond.Datatype"/></c>
			</f>
			<haxe_doc>
	 * Inserts a bond between the sentinel and the previous bond. Effectively, the newely added bond ends up being the last one
	 * in the list.
	 </haxe_doc>
		</add>
		<callListener public="1" set="method" line="296" override="1"><f a="data:currentTarget:origin:propagationStatus">
	<c path="hsl.haxe._DirectSignaler.SentinelBond.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<t path="hsl.haxe.Subject"/>
	<c path="Int"/>
	<c path="Int"/>
</f></callListener>
		<getIsConnected get="inline" set="null" line="307">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Determines whether this sentinel is connected to other bonds (true), or not (false).
	 </haxe_doc>
		</getIsConnected>
		<remove public="1" get="inline" set="null" line="317">
			<f a="value">
				<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.SentinelBond.Datatype"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes a bond connected to the sentinel.
	 * 
	 * The sentinel will look for the first bond equal to the passed value connected to it, and destroy it.
	 </haxe_doc>
		</remove>
		<new public="1" set="method" line="283">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Creates a new sentinel bond.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A sentinel "bond". The sentinel is not a real bond, as it does not bind the signaler to a listener. Rather it is the value
 * before the first bond and after the last bond of this signaler. It contains logic that helps the signaler working with the
 * linked list structure.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.RegularBond" params="Datatype" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<extends path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.RegularBond.Datatype"/></extends>
		<listener><f a="">
	<c path="hsl.haxe._DirectSignaler.RegularBond.Datatype"/>
	<e path="Void"/>
</f></listener>
		<callListener public="1" set="method" line="337" override="1"><f a="data:currentTarget:origin:propagationStatus">
	<c path="hsl.haxe._DirectSignaler.RegularBond.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<t path="hsl.haxe.Subject"/>
	<c path="Int"/>
	<c path="Int"/>
</f></callListener>
		<determineEquals set="method" line="346" override="1"><f a="value">
	<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.RegularBond.Datatype"/></c>
	<e path="Bool"/>
</f></determineEquals>
		<new public="1" set="method" line="333"><f a="listener">
	<f a="">
		<c path="hsl.haxe._DirectSignaler.RegularBond.Datatype"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * A regular bond is a bond that is created in result of a call to the bind method.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.NiladicBond" params="Datatype" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<extends path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.NiladicBond.Datatype"/></extends>
		<listener><f a=""><e path="Void"/></f></listener>
		<callListener public="1" set="method" line="369" override="1"><f a="data:currentTarget:origin:propagationStatus">
	<c path="hsl.haxe._DirectSignaler.NiladicBond.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<t path="hsl.haxe.Subject"/>
	<c path="Int"/>
	<c path="Int"/>
</f></callListener>
		<determineEquals set="method" line="378" override="1"><f a="value">
	<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.NiladicBond.Datatype"/></c>
	<e path="Bool"/>
</f></determineEquals>
		<new public="1" set="method" line="365">
			<f a="listener">
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new niladic bond.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A niladic bond is a bond that is created in result of a call to the bindVoid method.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.AdvancedBond" params="Datatype" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<extends path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.AdvancedBond.Datatype"/></extends>
		<listener><f a="">
	<c path="hsl.haxe.Signal"><c path="hsl.haxe._DirectSignaler.AdvancedBond.Datatype"/></c>
	<e path="Void"/>
</f></listener>
		<callListener public="1" set="method" line="401" override="1"><f a="data:currentTarget:origin:propagationStatus">
	<c path="hsl.haxe._DirectSignaler.AdvancedBond.Datatype"/>
	<t path="hsl.haxe.Subject"/>
	<t path="hsl.haxe.Subject"/>
	<c path="Int"/>
	<c path="Int"/>
</f></callListener>
		<determineEquals set="method" line="416" override="1"><f a="value">
	<c path="hsl.haxe._DirectSignaler.LinkedBond"><c path="hsl.haxe._DirectSignaler.AdvancedBond.Datatype"/></c>
	<e path="Bool"/>
</f></determineEquals>
		<new public="1" set="method" line="397">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.Signal"><c path="hsl.haxe._DirectSignaler.AdvancedBond.Datatype"/></c>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new advanced bond.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * An advanced bond is a bond that is created in result of a call to the bindAdvanced method.
 </haxe_doc>
	</class>
	<class path="hsl.haxe._DirectSignaler.PropagationStatus" params="" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/hsl/haxe/DirectSignaler.hx" private="1" module="hsl.haxe.DirectSignaler">
		<IMMEDIATELY_STOPPED public="1" get="inline" set="null" line="428" static="1"><c path="Int"/></IMMEDIATELY_STOPPED>
		<STOPPED public="1" get="inline" set="null" line="429" static="1"><c path="Int"/></STOPPED>
		<UNDISTURBED public="1" get="inline" set="null" line="430" static="1"><c path="Int"/></UNDISTURBED>
	</class>
	<class path="hsl.haxe.Signal" params="Datatype" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/hsl/haxe/Signal.hx">
		<currentBond public="1" set="null">
			<c path="hsl.haxe.Bond"/>
			<haxe_doc>
	 * The bond that is currently processing the signal.
	 </haxe_doc>
		</currentBond>
		<currentTarget public="1" set="null">
			<t path="hsl.haxe.Subject"/>
			<haxe_doc><![CDATA[
	 * The subject that is currently dispatching this signal. This subject might be the origin for this signal, but could also be
	 * dispatching this signal in a bubbling process. For instance, if a user clicks on a button that is inside a menu, and
	 * signals bubble from that button to that menu, the currentTarget will be the button at some point and the menu at another.
	 * The origin will constantly be the button. In other words, the currentTarget is the subject the listener added itself to.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this property is similar to the currentTarget property of the event objects in those systems.
	 * </li></ul>
	 * 
	 * In this example, the currentTarget property is used to determine which button was clicked. Note that this example is
	 * AVM2-specific, and requires the complete version of HSL (not just HSL-pico).
	 * <pre>
	 * package;
	 * import flash.display.Sprite;
	 * import flash.events.MouseEvent;
	 * import flash.Lib;
	 * import hsl.avm2.translating.AVM2Signaler;
	 * import hsl.haxe.direct.DirectSignaler;
	 * import hsl.haxe.Signal;
	 * import hsl.haxe.Signaler;
	 * class Main {
	 * 	public static function addButton(x:Float, color:Int):Void {
	 * 		var button:Button = new Button(color);
	 * 		button.x = x;
	 * 		button.clickedSignaler.bindAdvanced(handleButtonClicked);
	 * 		Lib.current.addChild(button);
	 * 	}
	 * 	public static function handleButtonClicked(signal:Signal&lt;Void&gt):Void {
	 * 		var button:Button = cast(signal.currentTarget, Button);
	 * 		trace("A button was clicked with this color: #" + StringTools.hex(button.color));
	 * 		removeButton(button);
	 * 	}
	 * 	private static function removeButton(button:Button):Void {
	 * 		button.clickedSignaler.unbindAdvanced(handleButtonClicked);
	 * 		Lib.current.removeChild(button);
	 * 	}
	 * 	public static function main():Void {
	 * 		addButton(0, 0x61C8E1);
	 * 		addButton(150, 0x61C8E1);
	 * 		addButton(300, 0xF68A1E);
	 * 		addButton(450, 0x61C8E1);
	 * 	}
	 * }
	 * class Button extends Sprite {
	 * 	public var clickedSignaler(default, null):Signaler&lt;Void&gt;;
	 * 	public var color:Int;
	 * 	public function new(color:Int):Void {
	 * 		super();
	 * 		clickedSignaler = new AVM2Signaler(this, this, MouseEvent.CLICK);
	 * 		this.color = color;
	 * 		buttonMode = true;
	 * 		draw();
	 * 	}
	 * 	private inline function draw():Void {
	 * 		graphics.beginFill(color);
	 * 		graphics.drawRoundRect(0, 0, 125, 77, 16);
	 * 		graphics.endFill();
	 * 	}
	 * }
	 * </pre>
	 * Note that this example is somewhat complex, and might be hard to understand if you are not familiar with the basics of
	 * this library.
	 ]]></haxe_doc>
		</currentTarget>
		<data public="1" set="null">
			<c path="hsl.haxe.Signal.Datatype"/>
			<haxe_doc>
	 * The data element in this signal.
	 </haxe_doc>
		</data>
		<data1 public="1" get="getData" set="null">
			<c path="hsl.haxe.Signal.Datatype"/>
			<haxe_doc>
	 * Deprecated. Equal to the data property.
	 </haxe_doc>
		</data1>
		<immediatePropagationStopped public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether stopImmediatePropagation method was called on this signal (true) or not (false).
	 </haxe_doc>
		</immediatePropagationStopped>
		<origin public="1" set="null">
			<t path="hsl.haxe.Subject"/>
			<haxe_doc><![CDATA[
	 * The subject that initially dispatched this signal. For instance, if a user clicks on a button that is inside a menu, and
	 * signals bubble from that button to that menu, the currentTarget will be the button at some point and the menu at another.
	 * The origin will constantly be the button. In other words, the origin is the subject that called the dispatch method.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this property is similar to the target property of the event objects in those systems.
	 * </li></ul>
	 ]]></haxe_doc>
		</origin>
		<propagationStopped public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether stopPropagation method was called on this signal (true) or not (false). stopPropagation calls on other
	 * signals, even in the same dispatch process, don't influence this property.
	 </haxe_doc>
		</propagationStopped>
		<getData get="inline" set="null" line="148"><f a=""><c path="hsl.haxe.Signal.Datatype"/></f></getData>
		<stopImmediatePropagation public="1" get="inline" set="null" line="213">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Stops all propagation of the signal. The subject currently dispatching this signal (as found in the target property of
	 * this the signal) stops doing so right away. Any other listeners that are listening are not notified.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this method is similar to the stopImmediatePropagation method of the event objects in those systems.
	 * </li></ul>
	 * 
	 * In this example, the stopImmediatePropagation method is used to mute the sound that was produces by the "Muter" class:
	 * <pre>
	 * package;
	 * import hsl.haxe.direct.DirectSignaler;
	 * import hsl.haxe.Bond;
	 * import hsl.haxe.Signal;
	 * import hsl.haxe.Signaler;
	 * class Main {
	 * 	public static function traceCheer():Void {
	 * 		trace("Yay!");
	 * 	}
	 * 	public static function main():Void {
	 * 		var speaker:Speaker = new Speaker();
	 * 		var muter:Muter = new Muter(speaker);
	 * 		speaker.soundProducedSignaler.bindVoid(traceCheer);
	 * 		// This has no effect: the muter stops the signal propagation.
	 * 		speaker.produceSound();
	 * 		muter.disable();
	 * 		// This traces the cheer: the muter is disabled.
	 * 		speaker.produceSound();
	 * 		muter.enable();
	 * 		// This has no effect: the muter is re-enabled.
	 * 		speaker.produceSound();
	 * 	}
	 * }
	 * class Speaker {
	 * 	public var soundProducedSignaler(default, null):Signaler&lt;Void&gt;;
	 * 	public function new():Void {
	 * 		soundProducedSignaler = new DirectSignaler(this);
	 * 	}
	 * 	public inline function produceSound():Void {
	 * 		soundProducedSignaler.dispatch();
	 * 	}
	 * }
	 * class Muter {
	 * 	private var muteBond:Bond;
	 * 	public function new(speaker:Speaker):Void {
	 * 		muteBond = speaker.soundProducedSignaler.bindAdvanced(mute);
	 * 	}
	 * 	public inline function disable():Void {
	 * 		muteBond.halt();
	 * 	}
	 * 	public inline function enable():Void {
	 * 		muteBond.resume();
	 * 	}
	 * 	private function mute(signal:Signal&lt;Void&gt;):Void {
	 * 		signal.stopImmediatePropagation();
	 * 	}
	 * }
	 * </pre>
	 * Note that this example is somewhat complex, and might be hard to understand if you are not familiar with the basics of
	 * this library.
	 ]]></haxe_doc>
		</stopImmediatePropagation>
		<stopPropagation public="1" get="inline" set="null" line="226">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Stops the bubbling of the signal. The subject currently dispatching this signal (as found in the target property of this
	 * the signal) will not bubble it to its bubbling targets. Calling this method does not prevent other listeners of the same
	 * signaler from being called: see stopImmediatePropagation for that functionality.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this method is similar to the stopPropagation method of the event objects in those systems.
	 * </li></ul>
	 ]]></haxe_doc>
		</stopPropagation>
		<new public="1" set="method" line="136">
			<f a="data:currentBond:currentTarget:origin">
				<c path="hsl.haxe.Signal.Datatype"/>
				<c path="hsl.haxe.Bond"/>
				<t path="hsl.haxe.Subject"/>
				<t path="hsl.haxe.Subject"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new signal. Signals are usually created by signalers, so this constructor will probably not be called outside of
	 * the library itself.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A signal is dispatched by a subject, through a signaler. However, only listeners that were added using the bindAdvanced
 * method can access the actual Signal instances.
 </haxe_doc>
	</class>
	<typedef path="hsl.haxe.Subject" params="" file="C:\Motion-Twin\Haxe\lib\hsl-pico-1/1,6/hsl/haxe/Subject.hx">
		<a/>
		<haxe_doc><![CDATA[
 * A subject is an object that might have internal state changes, which could be of interest to their environment. It notifies
 * its environment of such state changes by dispatching signals, rather than directly calling one of the methods of the
 * listeners. Subjects dispatch signals through signalers. Listeners can add themselves to those signalers.
 * 
 * Use of this technique results in low coupling between the subjects and their listeners. See
 * <a href="http://en.wikipedia.org/wiki/Coupling_(computer_science)">Coupling</a> on Wikipedia for more information.
 * 
 * Any class can act as a subject. Subjects can have any number of signalers.
 * 
 * In this example, the "buddy" variable (an instance of the "Dog" class) is a subject. The main class is a listener.
 * <pre>
 * package;
 * import hsl.haxe.direct.DirectSignaler;
 * import hsl.haxe.Signaler;
 * class Main {
 * 	public static function traceSound(sound:String):Void {
 * 		trace(sound);
 * 	}
 * 	public static function main():Void {
 * 		var buddy:Dog = new Dog();
 * 		buddy.barkedSignaler.bind(traceSound);
 * 		buddy.bark();
 * 	}
 * }
 * class Dog {
 * 	public var barkedSignaler(default, null):Signaler&lt;String&gt;;
 * 	public function new():Void {
 * 		barkedSignaler = new DirectSignaler(this);
 * 	}
 * 	public inline function bark():Void {
 * 		barkedSignaler.dispatch("Woof");
 * 	}
 * }
 * </pre>
 ]]></haxe_doc>
	</typedef>
	<class path="org.tbyrne.collections.IndexedList" params="T" file="../src/org/tbyrne/collections/IndexedList.hx">
		<_indices><c path="time.types.ds.ObjectHash">
	<c path="org.tbyrne.collections.IndexedList.T"/>
	<c path="Int"/>
</c></_indices>
		<list public="1" get="getlist" set="setlist"><c path="Array"><c path="org.tbyrne.collections.IndexedList.T"/></c></list>
		<getlist set="method" line="16"><f a=""><c path="Array"><c path="org.tbyrne.collections.IndexedList.T"/></c></f></getlist>
		<setlist set="method" line="23"><f a="value">
	<c path="Array"><c path="org.tbyrne.collections.IndexedList.T"/></c>
	<c path="Array"><c path="org.tbyrne.collections.IndexedList.T"/></c>
</f></setlist>
		<add public="1" set="method" line="44"><f a="value">
	<c path="org.tbyrne.collections.IndexedList.T"/>
	<e path="Bool"/>
</f></add>
		<remove public="1" set="method" line="54"><f a="value">
	<c path="org.tbyrne.collections.IndexedList.T"/>
	<e path="Bool"/>
</f></remove>
		<containsItem public="1" set="method" line="68"><f a="value">
	<c path="org.tbyrne.collections.IndexedList.T"/>
	<e path="Bool"/>
</f></containsItem>
		<clear public="1" set="method" line="71"><f a=""><e path="Void"/></f></clear>
		<new public="1" set="method" line="8"><f a="?list">
	<c path="Array"><c path="org.tbyrne.collections.IndexedList.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.tbyrne.composure.core.ComposeItem" params="" file="../src/org/tbyrne/composure/core/ComposeItem.hx">
		<parentItem public="1" get="getParentItem" set="setParentItem"><c path="org.tbyrne.composure.core.ComposeGroup"/></parentItem>
		<getParentItem set="method" line="17"><f a=""><c path="org.tbyrne.composure.core.ComposeGroup"/></f></getParentItem>
		<setParentItem set="method" line="20"><f a="value">
	<c path="org.tbyrne.composure.core.ComposeGroup"/>
	<c path="org.tbyrne.composure.core.ComposeGroup"/>
</f></setParentItem>
		<root public="1" get="getRoot" set="null"><c path="org.tbyrne.composure.core.ComposeRoot"/></root>
		<getRoot set="method" line="33"><f a=""><c path="org.tbyrne.composure.core.ComposeRoot"/></f></getRoot>
		<_parentItem><c path="org.tbyrne.composure.core.ComposeGroup"/></_parentItem>
		<_root><c path="org.tbyrne.composure.core.ComposeRoot"/></_root>
		<_traitCollection><c path="org.tbyrne.composure.traits.TraitCollection"/></_traitCollection>
		<_siblingMarrier><c path="org.tbyrne.composure.injectors.InjectorMarrier"/></_siblingMarrier>
		<_parentMarrier><c path="org.tbyrne.composure.injectors.InjectorMarrier"/></_parentMarrier>
		<_ascInjectors><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.injectors.IInjector"/></c></_ascInjectors>
		<_traitToCast><c path="time.types.ds.ObjectHash">
	<d/>
	<c path="org.tbyrne.composure.traits.ITrait"/>
</c></_traitToCast>
		<setRoot set="method" line="56"><f a="root">
	<c path="org.tbyrne.composure.core.ComposeRoot"/>
	<e path="Void"/>
</f></setRoot>
		<getTrait public="1" params="TraitType" set="method" line="59"><f a="TraitType">
	<c path="Class"><c path="getTrait.TraitType"/></c>
	<c path="getTrait.TraitType"/>
</f></getTrait>
		<getTraits public="1" params="TraitType" set="method" line="62"><f a="?TraitType">
	<c path="Class"><c path="getTraits.TraitType"/></c>
	<c path="Array"><c path="getTraits.TraitType"/></c>
</f></getTraits>
		<callForTraits public="1" set="method" line="71">
			<f a="func:?ifMatches">
				<f a=":">
					<c path="org.tbyrne.composure.core.ComposeItem"/>
					<c path="org.tbyrne.composure.traits.ITrait"/>
					<e path="Void"/>
				</f>
				<c path="Class"><c path="org.tbyrne.composure.traits.ITrait"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * handler(composeItem:ComposeItem, trait:ITrait);
	 </haxe_doc>
		</callForTraits>
		<addTrait public="1" set="method" line="74"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addTrait>
		<addTraits public="1" set="method" line="77"><f a="traits">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></addTraits>
		<_addTrait set="method" line="82"><f a="trait">
	<d/>
	<e path="Void"/>
</f></_addTrait>
		<removeTrait public="1" set="method" line="135"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeTrait>
		<removeTraits public="1" set="method" line="138"><f a="traits">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></removeTraits>
		<removeAllTraits public="1" set="method" line="143"><f a=""><e path="Void"/></f></removeAllTraits>
		<_removeTrait set="method" line="149"><f a="trait">
	<d/>
	<e path="Void"/>
</f></_removeTrait>
		<addTraitInjector set="method" line="175"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addTraitInjector>
		<removeTraitInjector set="method" line="185"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeTraitInjector>
		<onParentAdd set="method" line="196"><f a=""><e path="Void"/></f></onParentAdd>
		<onParentRemove set="method" line="206"><f a=""><e path="Void"/></f></onParentRemove>
		<addParentInjector set="method" line="218"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addParentInjector>
		<removeParentInjector set="method" line="222"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeParentInjector>
		<new public="1" set="method" line="45"><f a="?initTraits">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.tbyrne.composure.core.ComposeGroup" params="" file="../src/org/tbyrne/composure/core/ComposeGroup.hx">
		<extends path="org.tbyrne.composure.core.ComposeItem"/>
		<_descendantTraits><c path="org.tbyrne.composure.traits.TraitCollection"/></_descendantTraits>
		<_children><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.core.ComposeItem"/></c></_children>
		<_childAscInjectors><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.injectors.IInjector"/></c></_childAscInjectors>
		<_ignoredChildAscInjectors><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.injectors.IInjector"/></c></_ignoredChildAscInjectors>
		<_childAscendingMarrier><c path="org.tbyrne.composure.injectors.InjectorMarrier"/></_childAscendingMarrier>
		<_descInjectors><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.injectors.IInjector"/></c></_descInjectors>
		<_parentDescInjectors><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.injectors.IInjector"/></c></_parentDescInjectors>
		<_ignoredParentDescInjectors><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.injectors.IInjector"/></c></_ignoredParentDescInjectors>
		<setRoot set="method" line="32" override="1"><f a="game">
	<c path="org.tbyrne.composure.core.ComposeRoot"/>
	<e path="Void"/>
</f></setRoot>
		<addItem public="1" set="method" line="38"><f a="item">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Void"/>
</f></addItem>
		<removeItem public="1" set="method" line="64"><f a="item">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Void"/>
</f></removeItem>
		<removeAllItem public="1" set="method" line="90"><f a=""><e path="Void"/></f></removeAllItem>
		<addChildTrait public="1" set="method" line="95"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addChildTrait>
		<removeChildTrait public="1" set="method" line="99"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeChildTrait>
		<addTrait public="1" set="method" line="103" override="1"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addTrait>
		<addTraits public="1" set="method" line="107" override="1"><f a="traits">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></addTraits>
		<removeTrait public="1" set="method" line="111" override="1"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeTrait>
		<removeTraits public="1" set="method" line="115" override="1"><f a="traits">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></removeTraits>
		<removeAllTraits public="1" set="method" line="119" override="1"><f a=""><e path="Void"/></f></removeAllTraits>
		<addTraitInjector set="method" line="123" override="1"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addTraitInjector>
		<removeTraitInjector set="method" line="132" override="1"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeTraitInjector>
		<getDescTrait public="1" set="method" line="141"><f a="matchType">
	<c path="Class"><d/></c>
	<d/>
</f></getDescTrait>
		<getDescTraits public="1" set="method" line="144"><f a="?ifMatches">
	<c path="Class"><d/></c>
	<c path="Array"><d/></c>
</f></getDescTraits>
		<callForDescTraits public="1" set="method" line="147"><f a="func:?ifMatches">
	<f a=":">
		<c path="org.tbyrne.composure.core.ComposeItem"/>
		<d/>
		<e path="Void"/>
	</f>
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></callForDescTraits>
		<onParentAdd set="method" line="150" override="1"><f a=""><e path="Void"/></f></onParentAdd>
		<onParentRemove set="method" line="161" override="1"><f a=""><e path="Void"/></f></onParentRemove>
		<addAscendingInjector public="1" set="method" line="172"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addAscendingInjector>
		<_addAscendingInjector set="method" line="181"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></_addAscendingInjector>
		<removeAscendingInjector public="1" set="method" line="186"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeAscendingInjector>
		<_removeAscendingInjector set="method" line="194"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></_removeAscendingInjector>
		<addParentInjector set="method" line="199" override="1"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addParentInjector>
		<removeParentInjector set="method" line="209" override="1"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeParentInjector>
		<checkForNewlyIgnoredInjectors set="method" line="219"><f a=""><e path="Void"/></f></checkForNewlyIgnoredInjectors>
		<checkForNewlyUnignoredInjectors set="method" line="247"><f a=""><e path="Void"/></f></checkForNewlyUnignoredInjectors>
		<addDescParentInjector set="method" line="275"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addDescParentInjector>
		<removeDescParentInjector set="method" line="282"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeDescParentInjector>
		<new public="1" set="method" line="25"><f a="?initTraits">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.tbyrne.composure.core.ComposeRoot" params="" file="../src/org/tbyrne/composure/core/ComposeRoot.hx">
		<extends path="org.tbyrne.composure.core.ComposeGroup"/>
		<new public="1" set="method" line="6"><f a="?initTraits">
	<c path="Array"><c path="org.tbyrne.composure.traits.ITrait"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.tbyrne.composure.injectors.IInjector" params="" file="../src/org/tbyrne/composure/injectors/IInjector.hx" interface="1">
		<siblings public="1" set="null"><e path="Bool"/></siblings>
		<ascendants public="1" set="null"><e path="Bool"/></ascendants>
		<descendants public="1" set="null"><e path="Bool"/></descendants>
		<acceptOwnerTrait public="1" set="null"><e path="Bool"/></acceptOwnerTrait>
		<ownerTrait public="1"><d/></ownerTrait>
		<injectorAdded public="1" set="method"><f a="trait:item">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Void"/>
</f></injectorAdded>
		<injectorRemoved public="1" set="method"><f a="trait:item">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Void"/>
</f></injectorRemoved>
		<shouldDescend public="1" set="method"><f a="item">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldDescend>
		<shouldAscend public="1" set="method"><f a="item">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldAscend>
		<isInterestedIn public="1" set="method"><f a="trait">
	<d/>
	<e path="Bool"/>
</f></isInterestedIn>
	</class>
	<class path="org.tbyrne.composure.injectors.AbstractInjector" params="" file="../src/org/tbyrne/composure/injectors/AbstractInjector.hx">
		<implements path="org.tbyrne.composure.injectors.IInjector"/>
		<addHandler public="1"><d/></addHandler>
		<removeHandler public="1"><d/></removeHandler>
		<siblings public="1"><e path="Bool"/></siblings>
		<descendants public="1"><e path="Bool"/></descendants>
		<ascendants public="1"><e path="Bool"/></ascendants>
		<acceptOwnerTrait public="1"><e path="Bool"/></acceptOwnerTrait>
		<interestedTraitType public="1"><c path="Class"><d/></c></interestedTraitType>
		<ownerTrait public="1"><d/></ownerTrait>
		<passThroughInjector public="1"><e path="Bool"/></passThroughInjector>
		<passThroughItem public="1"><e path="Bool"/></passThroughItem>
		<_addedTraits><c path="org.tbyrne.collections.IndexedList"><d/></c></_addedTraits>
		<injectorAdded public="1" set="method" line="44"><f a="trait:item">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Void"/>
</f></injectorAdded>
		<injectorRemoved public="1" set="method" line="62"><f a="trait:item">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Void"/>
</f></injectorRemoved>
		<itemMatchesAll set="method" line="80"><f a="item:traitTypes">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<c path="Array"><c path="Class"><d/></c></c>
	<e path="Bool"/>
</f></itemMatchesAll>
		<itemMatchesAny set="method" line="88"><f a="item:traitTypes">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<c path="Array"><c path="Class"><d/></c></c>
	<e path="Bool"/>
</f></itemMatchesAny>
		<shouldDescend public="1" set="method" line="96"><f a="item">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldDescend>
		<shouldAscend public="1" set="method" line="100"><f a="item">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldAscend>
		<isInterestedIn public="1" set="method" line="104"><f a="trait">
	<d/>
	<e path="Bool"/>
</f></isInterestedIn>
		<new public="1" set="method" line="29"><f a="interestedTraitType:addHandler:removeHandler:?siblings:?descendants:?ascendants">
	<c path="Class"><d/></c>
	<d/>
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.tbyrne.composure.injectors.Injector" params="" file="../src/org/tbyrne/composure/injectors/Injector.hx">
		<extends path="org.tbyrne.composure.injectors.AbstractInjector"/>
		<unlessHasTraits public="1"><c path="Array"><c path="Class"><d/></c></c></unlessHasTraits>
		<additionalTraits public="1"><c path="Array"><c path="Class"><d/></c></c></additionalTraits>
		<stopDescendingAt public="1"><f a=":">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<c path="org.tbyrne.composure.injectors.Injector"/>
	<e path="Bool"/>
</f></stopDescendingAt>
		<stopAscendingAt public="1"><f a=":">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<c path="org.tbyrne.composure.injectors.Injector"/>
	<e path="Bool"/>
</f></stopAscendingAt>
		<matchProps public="1"><c path="Hash"><d/></c></matchProps>
		<maxMatches public="1"><c path="Int"/></maxMatches>
		<shouldDescend public="1" set="method" line="24" override="1"><f a="item">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldDescend>
		<shouldAscend public="1" set="method" line="31" override="1"><f a="item">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldAscend>
		<isInterestedIn public="1" set="method" line="38" override="1"><f a="trait">
	<d/>
	<e path="Bool"/>
</f></isInterestedIn>
		<propsMatch set="method" line="60"><f a="trait:props">
	<d/>
	<c path="Hash"><d/></c>
	<e path="Bool"/>
</f></propsMatch>
		<new public="1" set="method" line="17"><f a="interestedTraitType:addHandler:removeHandler:?siblings:?descendants:?ascendants">
	<c path="Class"><d/></c>
	<d/>
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.tbyrne.composure.injectors.InjectorMarrier" params="" file="../src/org/tbyrne/composure/injectors/InjectorMarrier.hx">
		<traits public="1" get="get_traits" set="set_traits"><c path="org.tbyrne.composure.traits.TraitCollection"/></traits>
		<get_traits set="method" line="15"><f a=""><c path="org.tbyrne.composure.traits.TraitCollection"/></f></get_traits>
		<set_traits set="method" line="18"><f a="value">
	<c path="org.tbyrne.composure.traits.TraitCollection"/>
	<c path="org.tbyrne.composure.traits.TraitCollection"/>
</f></set_traits>
		<traitInjectors public="1" get="getTraitInjectors" set="null"><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.injectors.IInjector"/></c></traitInjectors>
		<getTraitInjectors set="method" line="33"><f a=""><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.injectors.IInjector"/></c></f></getTraitInjectors>
		<_traits><c path="org.tbyrne.composure.traits.TraitCollection"/></_traits>
		<_traitInjectors><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.injectors.IInjector"/></c></_traitInjectors>
		<_injectorLookup><c path="time.types.ds.ObjectHash">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<c path="org.tbyrne.collections.IndexedList"><d/></c>
</c></_injectorLookup>
		<_traitLookup><c path="time.types.ds.ObjectHash">
	<d/>
	<c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.injectors.IInjector"/></c>
</c></_traitLookup>
		<_item><c path="org.tbyrne.composure.core.ComposeItem"/></_item>
		<addInjector public="1" set="method" line="57"><f a="traitInjector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addInjector>
		<removeInjector public="1" set="method" line="76"><f a="traitInjector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeInjector>
		<onTraitAdded set="method" line="119"><f a="trait">
	<d/>
	<e path="Void"/>
</f></onTraitAdded>
		<onTraitRemoved set="method" line="126"><f a="trait">
	<d/>
	<e path="Void"/>
</f></onTraitRemoved>
		<compareTrait set="method" line="142"><f a="trait:traitInjector">
	<d/>
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></compareTrait>
		<new public="1" set="method" line="48"><f a="item:traits">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<c path="org.tbyrne.composure.traits.TraitCollection"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.tbyrne.composure.injectors.PropInjector" params="" file="../src/org/tbyrne/composure/injectors/PropInjector.hx">
		<extends path="org.tbyrne.composure.injectors.Injector"/>
		<subject><d/></subject>
		<prop><c path="String"/></prop>
		<writeOnly><e path="Bool"/></writeOnly>
		<isSet><e path="Bool"/></isSet>
		<setTrait><d/></setTrait>
		<addProp set="method" line="24"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addProp>
		<removeProp set="method" line="38"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeProp>
		<new public="1" set="method" line="16"><f a="interestedTraitType:subject:prop:?siblings:?descendants:?ascendants:?writeOnly">
	<c path="Class"><d/></c>
	<d/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * ...
 * @author Tom Byrne
 </haxe_doc>
	</class>
	<class path="org.tbyrne.composure.macro.InjectorMacro" params="" file="../src/org/tbyrne/composure/macro/InjectorMacro.hx"><haxe_doc>
 * ...
 * @author Tom Byrne
 </haxe_doc></class>
	<class path="org.tbyrne.composure.macro.InjectorAccess" params="" file="../src/org/tbyrne/composure/macro/InjectorMacro.hx" module="org.tbyrne.composure.macro.InjectorMacro">
		<siblings public="1"><e path="Bool"/></siblings>
		<descendants public="1"><e path="Bool"/></descendants>
		<ascendants public="1"><e path="Bool"/></ascendants>
		<new public="1" set="method" line="293"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.tbyrne.composure.restrictions.ITraitRestriction" params="" file="../src/org/tbyrne/composure/restrictions/ITraitRestriction.hx" interface="1">
		<allowNewSibling public="1" set="method"><f a="owner:item:newTrait">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<d/>
	<e path="Bool"/>
</f></allowNewSibling>
		<allowAddTo public="1" set="method"><f a="owner:item">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></allowAddTo>
		<haxe_doc>
 * ...
 * @author Tom Byrne
 </haxe_doc>
	</class>
	<class path="org.tbyrne.composure.restrictions.SingularTraitRestriction" params="" file="../src/org/tbyrne/composure/restrictions/SingularTraitRestriction.hx">
		<implements path="org.tbyrne.composure.restrictions.ITraitRestriction"/>
		<getInheritedRestrictor public="1" set="method" line="15" static="1"><f a=""><c path="org.tbyrne.composure.restrictions.SingularTraitRestriction"/></f></getInheritedRestrictor>
		<getNonInheritedRestrictor public="1" set="method" line="21" static="1"><f a=""><c path="org.tbyrne.composure.restrictions.SingularTraitRestriction"/></f></getNonInheritedRestrictor>
		<_inheritedRestrictor static="1"><c path="org.tbyrne.composure.restrictions.SingularTraitRestriction"/></_inheritedRestrictor>
		<_nonInheritedRestrictor static="1"><c path="org.tbyrne.composure.restrictions.SingularTraitRestriction"/></_nonInheritedRestrictor>
		<restrictSubclasses public="1"><e path="Bool"/></restrictSubclasses>
		<lastOwner><c path="org.tbyrne.composure.traits.ITrait"/></lastOwner>
		<lastClass><c path="Class"><d/></c></lastClass>
		<allowNewSibling public="1" set="method" line="39"><f a="owner:item:newTrait">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<d/>
	<e path="Bool"/>
</f></allowNewSibling>
		<allowAddTo public="1" set="method" line="47"><f a="owner:item">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></allowAddTo>
		<validateForOwner set="method" line="62"><f a="owner">
	<c path="org.tbyrne.composure.traits.ITrait"/>
	<e path="Void"/>
</f></validateForOwner>
		<new set="method" line="36"><f a="restrictSubclasses">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * ...
 * @author Tom Byrne
 </haxe_doc>
	</class>
	<class path="org.tbyrne.composure.traits.ITrait" params="" file="../src/org/tbyrne/composure/traits/ITrait.hx" interface="1">
		<item public="1" set="set_item"><c path="org.tbyrne.composure.core.ComposeItem"/></item>
		<group public="1" set="null"><c path="org.tbyrne.composure.core.ComposeGroup"/></group>
		<getInjectors public="1" set="method"><f a=""><c path="Array"><c path="org.tbyrne.composure.injectors.IInjector"/></c></f></getInjectors>
		<getRestrictions public="1" set="method"><f a=""><c path="Array"><c path="org.tbyrne.composure.restrictions.ITraitRestriction"/></c></f></getRestrictions>
	</class>
	<class path="org.tbyrne.composure.traits.AbstractTrait" params="" file="../src/org/tbyrne/composure/traits/AbstractTrait.hx">
		<implements path="org.tbyrne.composure.traits.ITrait"/>
		<group public="1" set="null"><c path="org.tbyrne.composure.core.ComposeGroup"/></group>
		<item public="1" set="set_item"><c path="org.tbyrne.composure.core.ComposeItem"/></item>
		<set_item set="method" line="16"><f a="value">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
</f></set_item>
		<_injectors><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.injectors.IInjector"/></c></_injectors>
		<_restrictions><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.restrictions.ITraitRestriction"/></c></_restrictions>
		<_siblingTraits><c path="org.tbyrne.collections.IndexedList"><d/></c></_siblingTraits>
		<_childItems><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.core.ComposeItem"/></c></_childItems>
		<_groupOnly>
			<e path="Bool"/>
			<haxe_doc>
	 * Set to true to force Trait to only be added for groups.
	 </haxe_doc>
		</_groupOnly>
		<_ownerTrait><d/></_ownerTrait>
		<onItemRemove set="method" line="78"><f a=""><e path="Void"/></f></onItemRemove>
		<onItemAdd set="method" line="81"><f a=""><e path="Void"/></f></onItemAdd>
		<getInjectors public="1" set="method" line="85"><f a=""><c path="Array"><c path="org.tbyrne.composure.injectors.IInjector"/></c></f></getInjectors>
		<getRestrictions public="1" set="method" line="89"><f a=""><c path="Array"><c path="org.tbyrne.composure.restrictions.ITraitRestriction"/></c></f></getRestrictions>
		<addSiblingTrait set="method" line="94"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addSiblingTrait>
		<removeSiblingTrait set="method" line="105"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeSiblingTrait>
		<removeSiblingTraits set="method" line="115"><f a="traits">
	<c path="Array"><c path="org.tbyrne.composure.traits.ITrait"/></c>
	<e path="Void"/>
</f></removeSiblingTraits>
		<addChildItem set="method" line="121"><f a="child">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Void"/>
</f></addChildItem>
		<removeChildItem set="method" line="132"><f a="child">
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Void"/>
</f></removeChildItem>
		<removeChildItems set="method" line="142"><f a="children">
	<c path="Array"><c path="org.tbyrne.composure.core.ComposeItem"/></c>
	<e path="Void"/>
</f></removeChildItems>
		<addInjector public="1" set="method" line="148"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addInjector>
		<removeInjector public="1" set="method" line="157"><f a="injector">
	<c path="org.tbyrne.composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeInjector>
		<addRestriction set="method" line="167"><f a="restriction">
	<c path="org.tbyrne.composure.restrictions.ITraitRestriction"/>
	<e path="Void"/>
</f></addRestriction>
		<removeRestriction set="method" line="176"><f a="restriction">
	<c path="org.tbyrne.composure.restrictions.ITraitRestriction"/>
	<e path="Void"/>
</f></removeRestriction>
		<new public="1" set="method" line="70"><f a="?ownerTrait">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.tbyrne.composure.traits.TraitCollection" params="" file="../src/org/tbyrne/composure/traits/TraitCollection.hx">
		<traitAdded public="1" get="getTraitAdded" set="null"><c path="hsl.haxe.Signaler"><d/></c></traitAdded>
		<getTraitAdded set="method" line="18"><f a=""><c path="hsl.haxe.Signaler"><d/></c></f></getTraitAdded>
		<traitRemoved public="1" get="getTraitRemoved" set="null"><c path="hsl.haxe.Signaler"><d/></c></traitRemoved>
		<getTraitRemoved set="method" line="23"><f a=""><c path="hsl.haxe.Signaler"><d/></c></f></getTraitRemoved>
		<_traitRemoved><c path="hsl.haxe.Signaler"><d/></c></_traitRemoved>
		<_traitAdded><c path="hsl.haxe.Signaler"><d/></c></_traitAdded>
		<_traitTypeCache><c path="Hash"><c path="org.tbyrne.composure.traits._TraitCollection.TraitTypeCache"><d/></c></c></_traitTypeCache>
		<traits public="1" set="null"><c path="org.tbyrne.collections.IndexedList"><d/></c></traits>
		<getTrait public="1" params="TraitType" set="method" line="41"><f a="TraitType">
	<c path="Class"><c path="getTrait.TraitType"/></c>
	<c path="getTrait.TraitType"/>
</f></getTrait>
		<getTraits public="1" params="TraitType" set="method" line="55"><f a="?TraitType">
	<c path="Class"><c path="getTraits.TraitType"/></c>
	<c path="Array"><c path="getTraits.TraitType"/></c>
</f></getTraits>
		<validateCache public="1" params="TraitType" set="method" line="64"><f a="matchType">
	<c path="Class"><c path="validateCache.TraitType"/></c>
	<c path="org.tbyrne.composure.traits._TraitCollection.TraitTypeCache"><c path="validateCache.TraitType"/></c>
</f></validateCache>
		<callForTraits public="1" params="TraitType" set="method" line="97"><f a="func:matchType:thisObj:?params:?collectReturns">
	<d/>
	<c path="Class"><c path="callForTraits.TraitType"/></c>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></callForTraits>
		<addTrait public="1" set="method" line="157"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addTrait>
		<removeTrait public="1" set="method" line="167"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeTrait>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.tbyrne.composure.traits._TraitCollection.TraitTypeCache" params="TraitType" file="../src/org/tbyrne/composure/traits/TraitCollection.hx" private="1" module="org.tbyrne.composure.traits.TraitCollection">
		<methodCachesSafe public="1"><e path="Bool"/></methodCachesSafe>
		<getTrait public="1"><c path="org.tbyrne.composure.traits._TraitCollection.TraitTypeCache.TraitType"/></getTrait>
		<getTraits public="1"><c path="Array"><c path="org.tbyrne.composure.traits._TraitCollection.TraitTypeCache.TraitType"/></c></getTraits>
		<matched public="1"><c path="org.tbyrne.collections.IndexedList"><c path="org.tbyrne.composure.traits._TraitCollection.TraitTypeCache.TraitType"/></c></matched>
		<invalid public="1"><c path="org.tbyrne.collections.IndexedList"><d/></c></invalid>
		<new public="1" set="method" line="189"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.tbyrne.composure.utils.GenerationChecker" params="" file="../src/org/tbyrne/composure/utils/GenerationChecker.hx">
		<createTraitCheck public="1" set="method" line="15" static="1"><f a="?maxGenerations:relatedItem">
	<c path="Int"/>
	<e path="org.tbyrne.composure.utils.ItemType"/>
	<f a=":">
		<c path="org.tbyrne.composure.core.ComposeItem"/>
		<c path="org.tbyrne.composure.injectors.Injector"/>
		<e path="Bool"/>
	</f>
</f></createTraitCheck>
		<haxe_doc>
 * ...
 * @author Tom Byrne
 </haxe_doc>
	</class>
	<enum path="org.tbyrne.composure.utils.ItemType" params="" file="../src/org/tbyrne/composure/utils/GenerationChecker.hx" module="org.tbyrne.composure.utils.GenerationChecker">
		<specific a="ItemType"><c path="org.tbyrne.composure.core.ComposeItem"/></specific>
		<root/>
		<injectorItem/>
	</enum>
	<class path="org.tbyrne.composure.utils.TraitChecker" params="" file="../src/org/tbyrne/composure/utils/TraitChecker.hx">
		<createTraitCheck public="1" set="method" line="14" static="1"><f a="types:?useOrCheck">
	<c path="Array"><d/></c>
	<e path="Bool"/>
	<f a=":">
		<c path="org.tbyrne.composure.core.ComposeItem"/>
		<c path="org.tbyrne.composure.injectors.Injector"/>
		<e path="Bool"/>
	</f>
</f></createTraitCheck>
		<haxe_doc>
 * ...
 * @author Tom Byrne
 </haxe_doc>
	</class>
	<class path="org.tbyrne.composure.utils.TraitFurnisher" params="" file="../src/org/tbyrne/composure/utils/TraitFurnisher.hx">
		<extends path="org.tbyrne.composure.traits.AbstractTrait"/>
		<injectoredTraitType public="1" set="set_injectoredTraitType"><c path="Class"><d/></c></injectoredTraitType>
		<set_injectoredTraitType set="method" line="19"><f a="value">
	<c path="Class"><d/></c>
	<c path="Class"><d/></c>
</f></set_injectoredTraitType>
		<searchSiblings public="1" set="set_searchSiblings"><e path="Bool"/></searchSiblings>
		<set_searchSiblings set="method" line="34"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchSiblings>
		<searchDescendants public="1" set="set_searchDescendants"><e path="Bool"/></searchDescendants>
		<set_searchDescendants set="method" line="44"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchDescendants>
		<searchAscendants public="1" set="set_searchAscendants"><e path="Bool"/></searchAscendants>
		<set_searchAscendants set="method" line="54"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchAscendants>
		<adoptTrait public="1" set="set_adoptTrait"><e path="Bool"/></adoptTrait>
		<set_adoptTrait set="method" line="64"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_adoptTrait>
		<_addType><e path="org.tbyrne.composure.utils.AddType"/></_addType>
		<_injector><c path="org.tbyrne.composure.injectors.Injector"/></_injector>
		<_traits><c path="org.tbyrne.collections.IndexedList"><d/></c></_traits>
		<_traitTypes><c path="org.tbyrne.collections.IndexedList"><d/></c></_traitTypes>
		<_traitFactories><c path="org.tbyrne.collections.IndexedList"><f a=""><d/></f></c></_traitFactories>
		<_foundTraits><c path="org.tbyrne.collections.IndexedList"><d/></c></_foundTraits>
		<_addedTraits><c path="time.types.ds.ObjectHash">
	<d/>
	<c path="Array"><d/></c>
</c></_addedTraits>
		<_traitToItems><c path="time.types.ds.ObjectHash">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
</c></_traitToItems>
		<_originalItems><c path="time.types.ds.ObjectHash">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
</c></_originalItems>
		<_originalParents><c path="time.types.ds.ObjectHash">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeGroup"/>
</c></_originalParents>
		<_ignoreTraitChanges><e path="Bool"/></_ignoreTraitChanges>
		<onInjectoredTraitAdded set="method" line="122"><f a="trait:origItem">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onInjectoredTraitAdded>
		<onInjectoredTraitRemoved set="method" line="164"><f a="trait:currItem">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onInjectoredTraitRemoved>
		<addTrait public="1" set="method" line="189"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addTrait>
		<addTraitType public="1" set="method" line="204"><f a="traitType">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></addTraitType>
		<addTraitFactory public="1" set="method" line="220"><f a="traitFactory">
	<f a=""><d/></f>
	<e path="Void"/>
</f></addTraitFactory>
		<getItem set="method" line="236"><f a="trait">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
</f></getItem>
		<registerItem set="method" line="239"><f a="trait:origItem">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
</f></registerItem>
		<unregisterItem set="method" line="291"><f a="trait:currItem">
	<d/>
	<c path="org.tbyrne.composure.core.ComposeItem"/>
	<e path="Void"/>
</f></unregisterItem>
		<new public="1" set="method" line="103"><f a="addType:?injectoredTraitType:?traitTypes:?traitFactories:?searchSiblings:?searchDescendants:?searchAscendants:?adoptTrait">
	<e path="org.tbyrne.composure.utils.AddType"/>
	<c path="Class"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><f a=""><d/></f></c>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * ...
 * @author Tom Byrne
 </haxe_doc>
	</class>
	<enum path="org.tbyrne.composure.utils.AddType" params="" file="../src/org/tbyrne/composure/utils/TraitFurnisher.hx" module="org.tbyrne.composure.utils.TraitFurnisher">
		<traitSibling/>
		<traitItem/>
		<traitChild/>
		<selfSibling/>
		<selfItem/>
		<selfChild/>
		<itemSibling a="item"><c path="org.tbyrne.composure.core.ComposeItem"/></itemSibling>
		<itemChild a="group"><c path="org.tbyrne.composure.core.ComposeGroup"/></itemChild>
		<item a="item"><c path="org.tbyrne.composure.core.ComposeItem"/></item>
		<adoptItem a="newParent"><c path="org.tbyrne.composure.core.ComposeGroup"/></adoptItem>
	</enum>
	<class path="org.tbyrne.composureTest.ClassIncluder" params="" file="../testSrc/org/tbyrne/composureTest/ClassIncluder.hx"><main set="method" line="11" static="1"><f a=""><e path="Void"/></f></main></class>
	<class path="org.tbyrne.logging.LogMsg" params="" file="../src/org/tbyrne/logging/LogMsg.hx">
		<id public="1"><c path="String"/></id>
		<message public="1"><c path="String"/></message>
		<types public="1"><c path="Array"><c path="String"/></c></types>
		<title public="1"><c path="String"/></title>
		<new public="1" set="method" line="15"><f a="?message:?types:?title:?id">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * ...
 * @author Tom Byrne
 </haxe_doc>
	</class>
	<class path="org.tbyrne.logging.LogType" params="" file="../src/org/tbyrne/logging/LogMsg.hx" module="org.tbyrne.logging.LogMsg">
		<devInfo public="1" static="1"><c path="String"/></devInfo>
		<devWarning public="1" static="1"><c path="String"/></devWarning>
		<devError public="1" static="1"><c path="String"/></devError>
		<userInfo public="1" static="1"><c path="String"/></userInfo>
		<userWarning public="1" static="1"><c path="String"/></userWarning>
		<userError public="1" static="1"><c path="String"/></userError>
		<performanceWarning public="1" static="1"><c path="String"/></performanceWarning>
		<deprecationWarning public="1" static="1"><c path="String"/></deprecationWarning>
		<externalError public="1" static="1"><c path="String"/></externalError>
	</class>
	<class path="time.types.ds.ObjectHash" params="Key:Val" file="../src/time/types/ds/ObjectHash.hx">
		<SAFE_NUM get="inline" set="null" line="12" static="1"><c path="Int"/></SAFE_NUM>
		<clsId line="13" static="1"><c path="Int"/></clsId>
		<hashString set="method" line="81" static="1"><f a="str">
	<c path="String"/>
	<c path="Int"/>
</f></hashString>
		<ival><c path="IntHash"><c path="Array"><d/></c></c></ival>
		<length public="1" set="null"><c path="Int"/></length>
		<set public="1" set="method" line="38"><f a="k:v">
	<c path="time.types.ds.ObjectHash.Key"/>
	<c path="time.types.ds.ObjectHash.Val"/>
	<e path="Void"/>
</f></set>
		<getObjectId set="method" line="99"><f a="obj">
	<d/>
	<c path="Int"/>
</f></getObjectId>
		<get public="1" set="method" line="155"><f a="k">
	<c path="time.types.ds.ObjectHash.Key"/>
	<t path="Null"><c path="time.types.ds.ObjectHash.Val"/></t>
</f></get>
		<exists public="1" set="method" line="186"><f a="k">
	<c path="time.types.ds.ObjectHash.Key"/>
	<e path="Bool"/>
</f></exists>
		<remove public="1" set="method" line="216"><f a="k">
	<c path="time.types.ds.ObjectHash.Key"/>
	<e path="Bool"/>
</f></remove>
		<keys public="1" set="method" line="257"><f a=""><t path="Iterator"><c path="time.types.ds.ObjectHash.Key"/></t></f></keys>
		<iterator public="1" get="inline" set="null" line="287"><f a=""><t path="Iterator"><c path="time.types.ds.ObjectHash.Val"/></t></f></iterator>
		<toString public="1" set="method" line="317"><f a=""><c path="String"/></f></toString>
		<hxSerialize public="1" set="method" line="343"><f a="s">
	<c path="haxe.Serializer"/>
	<e path="Void"/>
</f></hxSerialize>
		<hxUnserialize public="1" set="method" line="379"><f a="s">
	<c path="haxe.Unserializer"/>
	<e path="Void"/>
</f></hxUnserialize>
		<new public="1" set="method" line="25"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * ...
 * @author waneck
 </haxe_doc>
	</class>
</haxe>